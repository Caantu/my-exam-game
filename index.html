<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ“˜å·å·è€ƒç ”å¤§ä½œæˆ˜</title>
    <link rel="manifest" href="data:application/json,{%22name%22:%22å·å·è€ƒç ”å¤§ä½œæˆ˜%22,%22short_name%22:%22è€ƒç ”å¤§ä½œæˆ˜%22,%22start_url%22:%22.%22,%22display%22:%22standalone%22,%22background_color%22:%22%23ffffff%22,%22theme_color%22:%22%234f46e5%22,%22icons%22:[{%22src%22:%22data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3EğŸ“˜%3C/text%3E%3C/svg%3E%22,%22sizes%22:%22192x192%22,%22type%22:%22image/svg+xml%22}]}">
    <meta name="theme-color" content="#4f46e5">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 420px;
            margin: 0 auto;
            background: white;
            min-height: 100vh;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }
        
        .header {
            background: linear-gradient(135deg, #4f46e5, #7c3aed);
            color: white;
            padding: 20px;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .countdown {
            font-size: 14px;
            opacity: 0.9;
        }
        
        .main-content {
            padding: 15px;
        }
        
        .status-card {
            background: linear-gradient(135deg, #fef3c7, #fbbf24);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .rank-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .rank-badge {
            background: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-weight: bold;
            color: #92400e;
        }
        
        .stars {
            font-size: 18px;
        }
        
        .section {
            background: white;
            border-radius: 12px;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            overflow: hidden;
        }
        
        .section-header {
            background: #f8fafc;
            padding: 12px 15px;
            border-bottom: 1px solid #e2e8f0;
            font-weight: bold;
            color: #1e293b;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .section-content {
            padding: 15px;
        }
        
        .task-item {
            padding: 10px;
            margin: 8px 0;
            background: #f1f5f9;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .task-completed {
            background: #dcfce7;
            text-decoration: line-through;
            opacity: 0.7;
        }
        
        .schedule-item {
            padding: 8px 0;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
        }
        
        .schedule-item:last-child {
            border-bottom: none;
        }
        
        .pk-card {
            background: linear-gradient(135deg, #fee2e2, #fecaca);
            border-radius: 12px;
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid #ef4444;
        }
        
        .pk-player {
            font-weight: bold;
            color: #dc2626;
            margin-bottom: 8px;
        }
        
        .pk-task {
            background: white;
            padding: 10px;
            border-radius: 8px;
            margin: 8px 0;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        
        .player-rank {
            font-weight: bold;
            color: #059669;
        }
        
        .my-rank {
            background: linear-gradient(135deg, #ddd6fe, #c4b5fd);
            margin: -8px -15px;
            padding: 8px 15px;
        }
        
        .reward-item {
            background: #fef7ff;
            border: 1px solid #e879f9;
            border-radius: 8px;
            padding: 10px;
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .story-card {
            background: linear-gradient(135deg, #f0f9ff, #dbeafe);
            border-radius: 12px;
            padding: 15px;
            border-left: 4px solid #3b82f6;
        }
        
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        
        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            text-decoration: none;
            display: inline-block;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #4f46e5, #7c3aed);
            color: white;
        }
        
        .btn-secondary {
            background: #f1f5f9;
            color: #475569;
            border: 1px solid #cbd5e1;
        }
        
        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .input-group {
            margin: 15px 0;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #374151;
        }
        
        .input-group input, .input-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 14px;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
        }
        
        .modal-content {
            background: white;
            max-width: 400px;
            margin: 50px auto;
            border-radius: 12px;
            overflow: hidden;
        }
        
        .modal-header {
            background: #4f46e5;
            color: white;
            padding: 15px;
            font-weight: bold;
        }
        
        .modal-body {
            padding: 20px;
        }
        
        .cat-mood {
            text-align: center;
            font-size: 48px;
            margin: 10px 0;
        }
        
        .hidden {
            display: none;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #10b981;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1001;
            transform: translateX(400px);
            transition: transform 0.3s;
        }
        
        .notification.show {
            transform: translateX(0);
        }
        
        .upload-area {
            border: 2px dashed #d1d5db;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin: 10px 0;
            cursor: pointer;
            transition: border-color 0.2s;
        }
        
        .upload-area:hover {
            border-color: #4f46e5;
        }
        
        .upload-area.dragover {
            border-color: #4f46e5;
            background: #f8fafc;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="title">ğŸ“˜å·å·è€ƒç ”å¤§ä½œæˆ˜</div>
            <div class="countdown" id="countdown">å€’è®¡æ—¶è®¡ç®—ä¸­...</div>
        </div>
        
        <div class="main-content">
            <!-- çŠ¶æ€å¡ç‰‡ -->
            <div class="status-card">
                <div class="rank-info">
                    <div>
                        <div class="rank-badge" id="rankBadge">é’é“œâ…¢</div>
                        <div style="margin-top: 5px; font-size: 12px;">æ’å <span id="ranking">5555</span></div>
                    </div>
                    <div class="stars" id="starDisplay">â˜…â˜†â˜†â˜†â˜†</div>
                </div>
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>âš¡ä»Šæ—¥æˆ˜åŠ›ï¼š<span id="todayPower">0</span>/100</div>
                    <div class="cat-mood" style="font-size: 24px;" id="catMood">ğŸ˜¾</div>
                </div>
                <div style="font-size: 12px; margin-top: 5px;" id="catStatus">å·å·å¿ƒæƒ…ï¼šé¥¿è‚šå­ç­‰ä½ æŠ•å–‚</div>
            </div>
            
            <!-- ä»Šæ—¥ä»»åŠ¡ -->
            <div class="section">
                <div class="section-header">
                    ğŸ”¥ ä»Šæ—¥ä»»åŠ¡
                </div>
                <div class="section-content">
                    <div class="upload-area" id="uploadArea">
                        <div>ğŸ“¸ ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ ä»»åŠ¡æ¸…å•</div>
                        <input type="file" id="fileInput" accept="image/*" style="display: none;">
                    </div>
                    <div id="taskList">
                        <div style="text-align: center; color: #6b7280; padding: 20px;">
                            å¾…æ‹ç…§å½•å…¥ä»»åŠ¡
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- å›ºå®šæ—¶é—´è§„åˆ’ -->
            <div class="section">
                <div class="section-header">
                    ğŸ•°ï¸ å›ºå®šæ—¶é—´è§„åˆ’
                    <div style="font-size: 11px; color: #6b7280; margin-left: auto;" id="currentScheduleHint">
                        æ­£åœ¨è·å–å½“å‰æ—¶ç¨‹...
                    </div>
                </div>
                <div class="section-content">
                    <div class="schedule-item" data-time="08:00-09:00">
                        <span>08:00-09:00</span>
                        <span>æ—©é¤+å•è¯</span>
                    </div>
                    <div class="schedule-item" data-time="09:00-13:45">
                        <span>09:00-13:45</span>
                        <span>408ä¸“ä¸šè¯¾</span>
                    </div>
                    <div class="schedule-item" data-time="13:45-14:05">
                        <span>13:45-14:05</span>
                        <span>åˆç¡</span>
                    </div>
                    <div class="schedule-item" data-time="14:10-19:30">
                        <span>14:10-19:30</span>
                        <span>æ•°å­¦äºŒ</span>
                    </div>
                    <div class="schedule-item" data-time="19:30-20:20">
                        <span>19:30-20:20</span>
                        <span>æ™šé¤</span>
                    </div>
                    <div class="schedule-item" data-time="20:20-21:05">
                        <span>20:20-21:05</span>
                        <span>è‹±è¯­ç²¾è¯»</span>
                    </div>
                    <div class="schedule-item" data-time="21:10-23:15">
                        <span>21:10-23:15</span>
                        <span>è®¡ç½‘+æ•°å­¦</span>
                    </div>
                    <div class="schedule-item" data-time="23:15-01:00">
                        <span>23:15-01:00</span>
                        <span>æ´—æ¼±+æ”¿æ²»</span>
                    </div>
                </div>
            </div>
            
            <!-- PKæŒ‘æˆ˜ -->
            <div class="section" id="pkSection" style="display: none;">
                <div class="section-header">
                    âš”ï¸ PKæŒ‘æˆ˜
                </div>
                <div class="section-content">
                    <div class="pk-card" id="pkCard">
                        <!-- PKå†…å®¹å°†åŠ¨æ€ç”Ÿæˆ -->
                    </div>
                </div>
            </div>
            
            <!-- æ’è¡Œæ¦œ -->
            <div class="section">
                <div class="section-header">
                    ğŸ† æ’è¡Œæ¦œ
                </div>
                <div class="section-content" id="leaderboard">
                    <!-- æ’è¡Œæ¦œå†…å®¹å°†åŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>
            
            <!-- å¥–åŠ±æ±  -->
            <div class="section">
                <div class="section-header">
                    ğŸ å¥–åŠ±æ± 
                </div>
                <div class="section-content" id="rewardPool">
                    <!-- å¥–åŠ±å†…å®¹å°†åŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>
            
            <!-- å‰§æƒ… -->
            <div class="section">
                <div class="section-header">
                    ğŸ“œ å½“å‰å‰§æƒ…
                </div>
                <div class="section-content">
                    <div class="story-card" id="storyContent">
                        <div style="font-weight: bold; margin-bottom: 8px;">ç¬¬ä¸€ç« ï¼šç ´ç¢çš„æ—¶é—´çº¿</div>
                        <div style="font-size: 14px; line-height: 1.5;">
                            å› è¿Ÿåˆ°ï¼Œæ—¶é—´æ€ªç‰©åäº†15åˆ†é’Ÿï¼å·å·æ‰“å·¥è¿˜å€ºä¸­â€¦<br>
                            âœ…å…¨éƒ¨ä»»åŠ¡å®Œæˆå¯è§£é”å‰§æƒ…ã€æ—¶é—´ä¿®å¤æœ¯ã€‘
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- æ“ä½œå° -->
            <div class="section">
                <div class="section-header">
                    ğŸ® æ“ä½œå°
                </div>
                <div class="section-content">
                    <div class="controls">
                        <button class="btn btn-primary" onclick="showTaskModal()">å®Œæˆä»»åŠ¡</button>
                        <button class="btn btn-secondary" onclick="showPkModal()">PKæŒ‘æˆ˜</button>
                        <button class="btn btn-primary" onclick="drawCard()">æŠ½å¡ (<span id="cardCount">0</span>åˆ¸)</button>
                        <button class="btn btn-secondary" onclick="showInventory()">æŸ¥çœ‹ä»“åº“</button>
                        <button class="btn btn-primary" onclick="showAIHelper()">AIåŠ©æ‰‹</button>
                        <button class="btn btn-secondary" onclick="showSettings()">è®¾ç½®</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- æ¨¡æ€æ¡† -->
    <div class="modal" id="taskModal">
        <div class="modal-content">
            <div class="modal-header">
                å®Œæˆä»»åŠ¡
            </div>
            <div class="modal-body">
                <div class="input-group">
                    <label>è¾“å…¥ä»»åŠ¡ç¼–å·ï¼ˆå¦‚ï¼št1, t2ï¼‰</label>
                    <input type="text" id="taskInput" placeholder="t1">
                </div>
                <div class="controls">
                    <button class="btn btn-primary" onclick="completeTask()">å®Œæˆ</button>
                    <button class="btn btn-secondary" onclick="closeModal()">å–æ¶ˆ</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <div class="modal-header">
                è®¾ç½®
            </div>
            <div class="modal-body">
                <div class="input-group">
                    <label>è±†åŒ…API Key</label>
                    <input type="password" id="apiKeyInput" placeholder="è¾“å…¥ä½ çš„è±†åŒ…API Key">
                </div>
                <div class="input-group">
                    <label>è±†åŒ…æ¥å…¥ç‚¹ID</label>
                    <input type="text" id="endpointIdInput" placeholder="ep-20250921171945-t4wjq">
                    <small style="color: #6b7280; font-size: 12px;">
                        åœ¨ç«å±±æ–¹èˆŸåˆ›å»ºæ¨ç†æ¥å…¥ç‚¹åè·å¾—çš„IDï¼ˆä½ çš„IDå·²è‡ªåŠ¨å¡«å…¥ï¼‰
                    </small>
                </div>
                <div class="input-group">
                    <label>è€ƒç ”æ—¥æœŸ</label>
                    <input type="date" id="examDateInput" value="2025-12-20">
                </div>
                <div style="background: #f0f9ff; padding: 10px; border-radius: 6px; margin: 10px 0; font-size: 12px;">
                    <strong>ğŸ“‹ è±†åŒ…APIé…ç½®æŒ‡å—ï¼š</strong><br>
                    1. è®¿é—® console.volcengine.com/ark/<br>
                    2. ä½ çš„API Key: 0b511afb-2045-499c-a445-c6ed91f140ba<br>
                    3. ä½ çš„æ¥å…¥ç‚¹ID: ep-20250921171945-t4wjq<br>
                    4. ç‚¹å‡»"æµ‹è¯•è¿æ¥"éªŒè¯é…ç½®æ˜¯å¦æ­£ç¡®<br>
                    <strong>ğŸ¯ AIåŠŸèƒ½ï¼š</strong>æ€§æ ¼åŒ–å¯¹è¯ã€å‰§æƒ…ç”Ÿæˆã€å­¦ä¹ å»ºè®®éƒ½ç”±è±†åŒ…AIå®ç°
                </div>
                <div class="controls">
                    <button class="btn btn-primary" onclick="saveSettings()">ä¿å­˜</button>
                    <button class="btn btn-secondary" onclick="testAIConnection()">æµ‹è¯•è¿æ¥</button>
                    <button class="btn btn-secondary" onclick="closeModal()">å–æ¶ˆ</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="modal" id="aiModal">
        <div class="modal-content">
            <div class="modal-header">
                AIåŠ©æ‰‹ - å·å·
            </div>
            <div class="modal-body">
                <div id="aiChatHistory" style="height: 300px; overflow-y: auto; border: 1px solid #e2e8f0; padding: 10px; margin-bottom: 10px; border-radius: 8px;">
                    <div style="text-align: center; color: #6b7280; padding: 20px;">
                        ğŸ± å·å·ï¼šæœ‰ä»€ä¹ˆå­¦ä¹ é—®é¢˜å¯ä»¥é—®æˆ‘å“¦ï¼
                    </div>
                </div>
                <div class="input-group">
                    <input type="text" id="aiInput" placeholder="å‘å·å·æé—®...">
                </div>
                <div class="controls">
                    <button class="btn btn-primary" onclick="sendToAI()">å‘é€</button>
                    <button class="btn btn-secondary" onclick="closeModal()">å…³é—­</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- é€šçŸ¥ -->
    <div class="notification" id="notification"></div>
    
    <script>
        // æ¸¸æˆæ•°æ®ç»“æ„
        let gameData = {
            rank: { level: 'bronze', tier: 3, stars: 1 },
            ranking: 5555,
            todayPower: 0,
            totalExp: 0,
            cardCount: 0,
            catMood: 'hungry',
            tasks: [],
            completedTasks: [],
            inventory: [],
            availableRewards: [],
            virtualPlayers: [], // è™šæ‹Ÿç©å®¶æ•°æ®
            playerRelationships: {}, // ä¸è™šæ‹Ÿç©å®¶çš„å…³ç³»
            settings: {
                apiKey: '',
                endpointId: '',
                examDate: '2025-12-20'
            },
            lastLoginDate: null,
            lastRewardCheck: null,
            lastTaskDate: null, // ä¸Šæ¬¡å®Œæˆä»»åŠ¡çš„æ—¥æœŸ
            pkChallenge: null,
            pkHistory: [], // PKå†å²è®°å½•
            story: { 
                chapter: 1, 
                unlocked: ['chapter1'],
                currentScene: 'prologue',
                characterRelationships: {
                    'professor_chen': 0, // é™ˆæ•™æˆå¥½æ„Ÿåº¦
                    'study_buddy_li': 0, // å­¦å‹å°æå¥½æ„Ÿåº¦
                    'rival_wang': 0 // ç«äº‰å¯¹æ‰‹å°ç‹å¥½æ„Ÿåº¦
                }
            },
            achievements: [], // æˆå°±ç³»ç»Ÿ
            streakDays: 0, // è¿ç»­å®Œæˆä»»åŠ¡å¤©æ•°
            stats: {
                totalTasksCompleted: 0,
                pkWins: 0,
                pkLosses: 0,
                pkDraws: 0,
                rewardsEarned: 0
            }
        };
        
        // æ•°æ®åº“æ“ä½œ
        let db;
        
        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('ExamGameDB', 1);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    if (!db.objectStoreNames.contains('gameData')) {
                        db.createObjectStore('gameData');
                    }
                };
            });
        }
        
        async function saveData() {
            const tx = db.transaction(['gameData'], 'readwrite');
            const store = tx.objectStore('gameData');
            await store.put(gameData, 'current');
            showNotification('æ•°æ®å·²ä¿å­˜ï¼');
        }
        
        async function loadData() {
            const tx = db.transaction(['gameData'], 'readonly');
            const store = tx.objectStore('gameData');
            const result = await store.get('current');
            if (result) {
                gameData = { ...gameData, ...result };
            }
        }
        
        // åˆå§‹åŒ–åº”ç”¨ï¼ˆAIå¢å¼ºç‰ˆï¼‰
        async function initApp() {
            await initDB();
            await loadData();
            
            // è®¾ç½®é»˜è®¤æ¥å…¥ç‚¹ID
            if (!gameData.settings.endpointId) {
                gameData.settings.endpointId = 'ep-20250921171945-t4wjq';
            }
            
            // åˆå§‹åŒ–å„ç§ç³»ç»Ÿ
            updateStoryDisplay();
            updateUI();
            updateCountdown();
            checkDailyReset();
            
            // å¼‚æ­¥åˆå§‹åŒ–è™šæ‹Ÿç©å®¶ï¼ˆAIç”Ÿæˆï¼‰
            initializeVirtualPlayers().then(() => {
                updateUI(); // é‡æ–°æ›´æ–°UIä»¥æ˜¾ç¤ºç”Ÿæˆçš„ç©å®¶
            });
            
            // å»¶è¿Ÿè§¦å‘éšæœºäº‹ä»¶ï¼Œé¿å…åˆå§‹åŒ–æ—¶ç«‹å³å¼¹çª—
            setTimeout(() => {
                generateRandomEvents();
            }, 5000);
            
            // è®¾ç½®å®šæ—¶å™¨
            setInterval(updateCountdown, 1000);
            setInterval(updateScheduleDisplay, 30000); // æ¯30ç§’æ›´æ–°æ—¶ç¨‹è¡¨
            setInterval(() => {
                if (Math.random() < 0.1) { // 10%æ¦‚ç‡è§¦å‘éšæœºäº‹ä»¶
                    generateRandomEvents();
                }
            }, 300000); // æ¯5åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
            
            // æ˜¾ç¤ºæ¬¢è¿ä¿¡æ¯
            if (gameData.stats.totalTasksCompleted === 0) {
                setTimeout(showWelcomeMessage, 1000);
            } else {
                setTimeout(() => {
                    showNotification('ğŸ¤– AIå¢å¼ºç³»ç»Ÿå·²æ¿€æ´»ï¼å¥–åŠ±ã€å‰§æƒ…ã€ç©å®¶éƒ½ç”±AIå®æ—¶ç”Ÿæˆï¼');
                }, 1500);
            }
        }
        
        function showWelcomeMessage() {
            showNotification('ğŸ® æ¬¢è¿æ¥åˆ°AIé©±åŠ¨çš„å·å·è€ƒç ”å¤§ä½œæˆ˜ï¼æ‹ç…§ä¸Šä¼ ä»Šæ—¥ä»»åŠ¡å¼€å§‹æ¸¸æˆå§ï¼');
            setTimeout(() => {
                showNotification('ğŸ¤– æœ¬æ¸¸æˆç”±è±†åŒ…AIæä¾›æ™ºèƒ½æ”¯æŒï¼Œæ¯æ¬¡ä½“éªŒéƒ½ç‹¬ä¸€æ— äºŒï¼');
            }, 3000);
        }
        
        // æ›´æ–°ç•Œé¢
        function updateUI() {
            updateRankDisplay();
            updateTaskList();
            updateLeaderboard();
            updateRewardPool();
            updateCatStatus();
            updateScheduleDisplay();
            document.getElementById('cardCount').textContent = gameData.cardCount;
        }
        
        function updateCountdown() {
            const examDate = new Date('2025-12-20');
            const now = new Date();
            const diff = examDate - now;
            const days = Math.ceil(diff / (1000 * 60 * 60 * 24));
            
            const today = now.toLocaleDateString('zh-CN', { 
                month: 'long', 
                day: 'numeric' 
            });
            
            let countdownText;
            if (days > 0) {
                countdownText = `${today} Â· è·ç¦»2025è€ƒç ”è¿˜æœ‰${days}å¤©`;
            } else if (days === 0) {
                countdownText = `${today} Â· è€ƒç ”å°±æ˜¯ä»Šå¤©ï¼åŠ æ²¹ï¼`;
            } else {
                countdownText = `${today} Â· è€ƒç ”å·²ç»“æŸ${Math.abs(days)}å¤©`;
            }
            
            document.getElementById('countdown').textContent = countdownText;
        }
        
        function updateRankDisplay() {
            const ranks = {
                bronze: 'é’é“œ', silver: 'ç™½é“¶', gold: 'é»„é‡‘',
                platinum: 'é“‚é‡‘', diamond: 'é’»çŸ³', 
                master: 'æ˜Ÿè€€', king: 'ç‹è€…'
            };
            
            const rankName = ranks[gameData.rank.level];
            const romanNumerals = ['', 'â… ', 'â…¡', 'â…¢', 'â…£', 'â…¤'];
            
            document.getElementById('rankBadge').textContent = 
                `${rankName}${romanNumerals[gameData.rank.tier]}`;
            
            document.getElementById('ranking').textContent = gameData.ranking;
            
            const stars = 'â˜…'.repeat(gameData.rank.stars) + 
                         'â˜†'.repeat(5 - gameData.rank.stars);
            document.getElementById('starDisplay').textContent = stars;
            
            document.getElementById('todayPower').textContent = gameData.todayPower;
        }
        
        function updateCatStatus() {
            const moods = {
                happy: { emoji: 'ğŸ˜¸', text: 'å¼€å¿ƒåœ°é™ªä½ å­¦ä¹ ' },
                hungry: { emoji: 'ğŸ˜¾', text: 'é¥¿è‚šå­ç­‰ä½ æŠ•å–‚' },
                sleepy: { emoji: 'ğŸ˜´', text: 'å›°å›°æƒ³è¦ç¡è§‰è§‰' },
                excited: { emoji: 'ğŸ¤©', text: 'è¶…å…´å¥‹æƒ³è¦å†²å†²å†²' },
                content: { emoji: 'ğŸ˜Š', text: 'æ»¡è¶³åœ°çœ‹ç€ä½ è¿›æ­¥' },
                sad: { emoji: 'ğŸ˜¿', text: 'ä¸ºä½ çš„é€€æ­¥æ„Ÿåˆ°éš¾è¿‡' },
                disappointed: { emoji: 'ğŸ˜¼', text: 'æœ‰ç‚¹å¤±æœ›ä½†è¿˜æ˜¯æ”¯æŒä½ ' }
            };
            
            const mood = moods[gameData.catMood] || moods.hungry;
            document.getElementById('catMood').textContent = mood.emoji;
            document.getElementById('catStatus').textContent = `å·å·å¿ƒæƒ…ï¼š${mood.text}`;
            
            // æ ¹æ®å¿ƒæƒ…è°ƒæ•´æ˜¾ç¤ºæ•ˆæœ
            const catMoodElement = document.getElementById('catMood');
            catMoodElement.style.transform = gameData.catMood === 'excited' ? 'scale(1.2)' : 'scale(1)';
            catMoodElement.style.filter = gameData.catMood === 'sad' ? 'grayscale(50%)' : 'none';
        }
        
        function updateTaskList() {
            const container = document.getElementById('taskList');
            if (gameData.tasks.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; color: #6b7280; padding: 20px;">
                        å¾…æ‹ç…§å½•å…¥ä»»åŠ¡
                    </div>
                `;
                return;
            }
            
            container.innerHTML = gameData.tasks.map((task, index) => `
                <div class="task-item ${gameData.completedTasks.includes(index) ? 'task-completed' : ''}">
                    <span>t${index + 1}. ${task}</span>
                    <span>${gameData.completedTasks.includes(index) ? 'âœ…' : 'â³'}</span>
                </div>
            `).join('');
        }
        
        function generateVirtualPlayers() {
            // ç¡®ä¿è™šæ‹Ÿç©å®¶å·²åˆå§‹åŒ–
            if (gameData.virtualPlayers.length === 0) {
                initializeVirtualPlayers();
                return []; // å¼‚æ­¥åˆå§‹åŒ–ä¸­ï¼Œå…ˆè¿”å›ç©ºæ•°ç»„
            }
            
            updateVirtualPlayers();
            
            // æ ¹æ®æ®µä½æ’åº
            const sortedPlayers = [...gameData.virtualPlayers].sort((a, b) => {
                const rankOrder = ['king', 'master', 'diamond', 'platinum', 'gold', 'silver', 'bronze'];
                const aRankIndex = rankOrder.indexOf(a.rankLevel);
                const bRankIndex = rankOrder.indexOf(b.rankLevel);
                
                if (aRankIndex !== bRankIndex) return aRankIndex - bRankIndex;
                if (a.tier !== b.tier) return a.tier - b.tier;
                return b.stars - a.stars;
            });
            
            // æ’å…¥ç”¨æˆ·
            const userRanking = gameData.ranking;
            const ranks = { bronze: 'é’é“œ', silver: 'ç™½é“¶', gold: 'é»„é‡‘', platinum: 'é“‚é‡‘', diamond: 'é’»çŸ³', master: 'æ˜Ÿè€€', king: 'ç‹è€…' };
            const romanNumerals = ['', 'â… ', 'â…¡', 'â…¢', 'â…£', 'â…¤'];
            
            const myPlayer = {
                name: 'ä½ ',
                rankLevel: gameData.rank.level,
                tier: gameData.rank.tier,
                stars: gameData.rank.stars,
                ranking: userRanking,
                displayRank: `${ranks[gameData.rank.level]}${romanNumerals[gameData.rank.tier]}`,
                displayStars: 'â˜…'.repeat(gameData.rank.stars) + 'â˜†'.repeat(5 - gameData.rank.stars)
            };
            
            // ä¸ºè™šæ‹Ÿç©å®¶æ·»åŠ æ˜¾ç¤ºä¿¡æ¯
            sortedPlayers.forEach((player, index) => {
                player.ranking = index + 1;
                player.displayRank = `${ranks[player.rankLevel]}${romanNumerals[player.tier]}`;
                player.displayStars = 'â˜…'.repeat(player.stars) + 'â˜†'.repeat(5 - player.stars);
            });
            
            sortedPlayers.splice(userRanking - 1, 0, myPlayer);
            
            // æ˜¾ç¤ºå‰3å + ç”¨æˆ·é™„è¿‘çš„ç©å®¶
            const displayPlayers = [];
            
            // å‰3å
            displayPlayers.push(...sortedPlayers.slice(0, 3));
            
            if (userRanking > 6) {
                displayPlayers.push({ name: '...', displayRank: '', displayStars: '', ranking: '...' });
            }
            
            // ç”¨æˆ·é™„è¿‘çš„ç©å®¶
            const start = Math.max(0, userRanking - 2);
            const end = Math.min(sortedPlayers.length, userRanking + 2);
            
            if (userRanking > 3) {
                displayPlayers.push(...sortedPlayers.slice(start, end));
            }
            
            return displayPlayers;
        }
        
        function updateLeaderboard() {
            const players = generateVirtualPlayers();
            const container = document.getElementById('leaderboard');
            
            if (players.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; color: #6b7280; padding: 20px;">
                        ğŸ¤– æ­£åœ¨ç”Ÿæˆè™šæ‹Ÿç©å®¶...
                    </div>
                `;
                return;
            }
            
            container.innerHTML = players.map((player) => {
                const isMyRank = player.name === 'ä½ ';
                const isDivider = player.name === '...';
                
                if (isDivider) {
                    return `
                        <div class="leaderboard-item" style="text-align: center; color: #6b7280;">
                            <span>...</span>
                        </div>
                    `;
                }
                
                // æ·»åŠ è¿›æ­¥/é€€æ­¥æŒ‡ç¤ºå™¨å’ŒAIæ ‡è¯†
                let trendIcon = '';
                let aiIcon = '';
                
                if (player.momentum !== undefined) {
                    if (player.momentum > 0.3) trendIcon = 'ğŸ“ˆ';
                    else if (player.momentum < -0.3) trendIcon = 'ğŸ“‰';
                    else trendIcon = 'â¡ï¸';
                }
                
                if (player.aiGenerated) {
                    aiIcon = 'ğŸ¤–';
                }
                
                return `
                    <div class="leaderboard-item ${isMyRank ? 'my-rank' : ''}">
                        <span class="player-rank">${player.ranking}. ${player.name} ${trendIcon}${aiIcon}</span>
                        <span>${player.displayRank} ${player.displayStars}</span>
                    </div>
                `;
            }).join('');
        }
        
        // æ˜¾ç¤ºä»“åº“ï¼ˆæ”¯æŒAIç”Ÿæˆæ ‡è¯†ï¼‰
        function showInventory() {
            let inventoryHTML = gameData.inventory.length === 0 
                ? 'ä»“åº“ç©ºç©ºå¦‚ä¹Ÿ...' 
                : gameData.inventory.map((item, index) => {
                    const aiIcon = item.aiGenerated ? ' ğŸ¤–' : '';
                    const generateButton = (item.type === 'costume' && item.costume) ? 
                        `<button class="btn btn-primary" style="padding: 2px 6px; font-size: 10px;" onclick="generateFromInventory(${index})">ç”Ÿæˆå›¾ç‰‡</button>` : '';
                    
                    return `
                        <div style="padding: 8px; margin: 4px 0; background: #f8fafc; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div>${item.name}${aiIcon}</div>
                                ${item.description ? `<div style="font-size: 10px; color: #6b7280;">${item.description}</div>` : ''}
                            </div>
                            ${generateButton}
                        </div>
                    `;
                }).join('');
            
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        ğŸ“¦ æˆ‘çš„ä»“åº“
                        <div style="font-size: 11px; opacity: 0.8;">ğŸ¤– = AIç”Ÿæˆç‰©å“</div>
                    </div>
                    <div class="modal-body">
                        <div style="max-height: 300px; overflow-y: auto;">
                            ${inventoryHTML}
                        </div>
                        <button class="btn btn-secondary" onclick="this.closest('.modal').remove()">å…³é—­</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        // AIç”Ÿæˆè™šæ‹Ÿç©å®¶ç³»ç»Ÿ
        async function generateAIPlayer() {
            const prompt = `ç”Ÿæˆä¸€ä¸ªè€ƒç ”æ¸¸æˆä¸­çš„è™šæ‹Ÿç©å®¶ï¼Œè¦æ±‚ï¼š

è¦æ±‚ï¼š
1. å§“åï¼šæœ‰åˆ›æ„çš„è€ƒç ”ç›¸å…³æ˜µç§°ï¼Œä¸è¦é‡å¤å¸¸è§çš„
2. æ€§æ ¼ï¼šä»è¿™äº›ä¸­é€‰ä¸€ä¸ª - confident,shy,aggressive,supportive,silent,sarcastic,cheerful,competitive
3. ä¸“ä¸šï¼šæ•°å­¦ã€è‹±è¯­ã€æ”¿æ²»ã€è®¡ç®—æœºã€ç»¼åˆç­‰
4. æ®µä½ï¼šbronze,silver,gold,platinum,diamond,master,king
5. æ˜Ÿçº§ï¼š1-5
6. èƒŒæ™¯æ•…äº‹ï¼šä¸€å¥è¯çš„ç®€çŸ­èƒŒæ™¯

å›å¤æ ¼å¼ï¼šå§“å|æ€§æ ¼|ä¸“ä¸š|æ®µä½|æ˜Ÿçº§|èƒŒæ™¯æ•…äº‹
ç¤ºä¾‹ï¼šå¤œç©ºå®ˆæœ›è€…|shy|æ•°å­¦|gold|3|æ¥è‡ªå°åŸå¸‚çš„æ•°å­¦å¤©æ‰ï¼Œæ¢¦æƒ³è€ƒå…¥985

ä¸€è¡Œå›å¤ï¼Œä¸è¦å¤šä½™å†…å®¹`;

            try {
                const response = await callDoubaoAPI(prompt);
                const parts = response.split('|');
                
                if (parts.length >= 6) {
                    return {
                        name: parts[0].trim(),
                        personality: parts[1].trim(),
                        subject: parts[2].trim(),
                        rankLevel: parts[3].trim(),
                        stars: parseInt(parts[4].trim()) || Math.floor(Math.random() * 5) + 1,
                        tier: Math.floor(Math.random() * 5) + 1,
                        background: parts[5].trim(),
                        lastActive: new Date().toISOString(),
                        momentum: Math.random() * 2 - 1,
                        relationshipWithUser: Math.random() * 2 - 1,
                        aiGenerated: true
                    };
                } else {
                    throw new Error('AIå›å¤æ ¼å¼é”™è¯¯');
                }
            } catch (error) {
                console.error('AIç©å®¶ç”Ÿæˆå¤±è´¥:', error);
                return generateFallbackPlayer();
            }
        }
        
        function generateFallbackPlayer() {
            const names = ['å­¦ä¹ è¾¾äºº', 'åˆ·é¢˜æœºå™¨', 'è€ƒç ”æˆ˜å£«', 'çŸ¥è¯†æ¢ç´¢è€…', 'å­¦éœ¸ä¹‹è·¯'];
            const personalities = ['confident', 'shy', 'aggressive', 'supportive', 'competitive'];
            const subjects = ['æ•°å­¦', 'è‹±è¯­', 'æ”¿æ²»', 'è®¡ç®—æœº', 'ç»¼åˆ'];
            const levels = ['bronze', 'silver', 'gold', 'platinum', 'diamond'];
            
            return {
                name: names[Math.floor(Math.random() * names.length)] + Math.floor(Math.random() * 999),
                personality: personalities[Math.floor(Math.random() * personalities.length)],
                subject: subjects[Math.floor(Math.random() * subjects.length)],
                rankLevel: levels[Math.floor(Math.random() * levels.length)],
                tier: Math.floor(Math.random() * 5) + 1,
                stars: Math.floor(Math.random() * 5) + 1,
                background: 'ç¥ç§˜çš„è€ƒç ”ç©å®¶',
                lastActive: new Date().toISOString(),
                momentum: Math.random() * 2 - 1,
                relationshipWithUser: Math.random() * 2 - 1,
                aiGenerated: false
            };
        }
        
        // AIç”Ÿæˆå‰§æƒ…äº‹ä»¶
        async function generateAIStoryEvent() {
            const prompt = `ä½ æ˜¯è€ƒç ”æ¸¸æˆçš„å‰§æƒ…ç”Ÿæˆç³»ç»Ÿã€‚åŸºäºç”¨æˆ·å½“å‰çŠ¶å†µç”Ÿæˆä¸€ä¸ªå‰§æƒ…äº‹ä»¶ï¼š

ç”¨æˆ·å½“å‰çŠ¶å†µï¼š
- ç´¯è®¡å®Œæˆä»»åŠ¡ï¼š${gameData.stats.totalTasksCompleted}ä¸ª
- è¿ç»­å­¦ä¹ ï¼š${gameData.streakDays}å¤©
- å½“å‰æ®µä½ï¼š${gameData.rank.level} ${gameData.rank.tier}æ®µ ${gameData.rank.stars}æ˜Ÿ
- PKæˆ˜ç»©ï¼š${gameData.stats.pkWins}èƒœ${gameData.stats.pkLosses}è´Ÿ
- å½“å‰æ—¶é—´ï¼š${new Date().getHours()}:${new Date().getMinutes()}

ç”Ÿæˆè¦æ±‚ï¼š
1. äº‹ä»¶æ ‡é¢˜ï¼šç®€çŸ­æœ‰è¶£çš„æ ‡é¢˜
2. äº‹ä»¶å†…å®¹ï¼š100å­—ä»¥å†…çš„å‰§æƒ…æè¿°ï¼Œè¦ç»“åˆç”¨æˆ·çŠ¶å†µ
3. é€‰æ‹©1ï¼šç¬¬ä¸€ä¸ªè¡ŒåŠ¨é€‰æ‹©åŠç®€çŸ­æ•ˆæœæè¿°
4. é€‰æ‹©2ï¼šç¬¬äºŒä¸ªè¡ŒåŠ¨é€‰æ‹©åŠç®€çŸ­æ•ˆæœæè¿°

å›å¤æ ¼å¼ï¼š
æ ‡é¢˜|å†…å®¹|é€‰æ‹©1|æ•ˆæœ1|é€‰æ‹©2|æ•ˆæœ2

ç¤ºä¾‹ï¼š
å›¾ä¹¦é¦†çš„ç¥ç§˜çº¸æ¡|ä½ åœ¨å›¾ä¹¦é¦†åº§ä½ä¸Šå‘ç°äº†ä¸€å¼ ç¥ç§˜çº¸æ¡ï¼Œä¸Šé¢å†™ç€å­¦ä¹ æŠ€å·§å’Œé¼“åŠ±çš„è¯|ä»”ç»†ç ”ç©¶çº¸æ¡|è·å¾—å­¦ä¹ åŠ é€Ÿå¡|å¯»æ‰¾çº¸æ¡ä¸»äºº|å¯èƒ½é‡åˆ°å­¦ä¹ ä¼™ä¼´

è¦æ±‚ï¼š
- å‰§æƒ…è¦æœ‰è¶£ã€è´´åˆè€ƒç ”ä¸»é¢˜
- é€‰æ‹©è¦æœ‰æ˜æ˜¾åŒºåˆ«å’Œåæœ
- ä¸€è¡Œå›å¤ï¼Œä¸è¦å¤šä½™å†…å®¹`;

            try {
                const response = await callDoubaoAPI(prompt);
                const parts = response.split('|');
                
                if (parts.length >= 6) {
                    return {
                        id: 'ai_event_' + Date.now(),
                        title: parts[0].trim(),
                        content: parts[1].trim(),
                        choices: [
                            {
                                text: parts[2].trim(),
                                effect: () => applyStoryEffect(parts[3].trim())
                            },
                            {
                                text: parts[4].trim(),
                                effect: () => applyStoryEffect(parts[5].trim())
                            }
                        ],
                        aiGenerated: true
                    };
                } else {
                    throw new Error('AIå›å¤æ ¼å¼é”™è¯¯');
                }
            } catch (error) {
                console.error('AIå‰§æƒ…ç”Ÿæˆå¤±è´¥:', error);
                return generateFallbackStoryEvent();
            }
        }
        
        function generateFallbackStoryEvent() {
            const events = [
                {
                    id: 'fallback_event',
                    title: 'å­¦ä¹ å°æ’æ›²',
                    content: 'åœ¨å­¦ä¹ è¿‡ç¨‹ä¸­é‡åˆ°äº†ä¸€ä¸ªå°æƒ…å†µ...',
                    choices: [
                        { text: 'ç»§ç»­å­¦ä¹ ', effect: () => applyStoryEffect('è·å¾—ä¸“æ³¨åŠ æˆ') },
                        { text: 'ç¨ä½œä¼‘æ¯', effect: () => applyStoryEffect('æ¢å¤ç²¾ç¥çŠ¶æ€') }
                    ],
                    aiGenerated: false
                }
            ];
            
            return events[0];
        }
        
        function applyStoryEffect(effectDescription) {
            // æ ¹æ®æ•ˆæœæè¿°åº”ç”¨æ¸¸æˆæ•ˆæœ
            if (effectDescription.includes('åŠ é€Ÿå¡') || effectDescription.includes('ä¸“æ³¨')) {
                gameData.inventory.push({ type: 'virtual', name: 'å­¦ä¹ åŠ é€Ÿå¡Ã—1' });
                showNotification(`ğŸ“š ${effectDescription}ï¼è·å¾—å­¦ä¹ åŠ é€Ÿå¡ï¼`);
            } else if (effectDescription.includes('ç»éªŒ') || effectDescription.includes('æˆ˜åŠ›')) {
                gameData.todayPower += 15;
                showNotification(`âš¡ ${effectDescription}ï¼+15æˆ˜åŠ›ï¼`);
            } else if (effectDescription.includes('è£…æ‰®') || effectDescription.includes('å¥–åŠ±')) {
                gameData.cardCount += 1;
                showNotification(`ğŸ ${effectDescription}ï¼è·å¾—æŠ½å¡åˆ¸Ã—1ï¼`);
            } else if (effectDescription.includes('å­¦ä¹ ä¼™ä¼´') || effectDescription.includes('æœ‹å‹')) {
                // åŠ å…¥æ–°çš„AIç”Ÿæˆè™šæ‹Ÿç©å®¶
                generateAIPlayer().then(newPlayer => {
                    gameData.virtualPlayers.push(newPlayer);
                    showNotification(`ğŸ‘¥ ${effectDescription}ï¼é‡åˆ°äº†æ–°æœ‹å‹ï¼š${newPlayer.name}ï¼`);
                });
            } else {
                // é»˜è®¤æ•ˆæœ
                gameData.todayPower += 10;
                showNotification(`âœ¨ ${effectDescription}ï¼`);
            }
        }
        
        // æ™ºèƒ½è™šæ‹Ÿç©å®¶åˆå§‹åŒ–ç³»ç»Ÿ
        async function initializeVirtualPlayers() {
            if (gameData.virtualPlayers.length === 0) {
                showNotification('ğŸ¤– æ­£åœ¨ç”Ÿæˆè™šæ‹Ÿç©å®¶...');
                
                // ç”Ÿæˆä¸€äº›åŸºç¡€ç©å®¶
                const basicPlayers = [
                    { name: 'åŒ—å¤§ç‹™ç¥', personality: 'confident', subject: 'math', rankLevel: 'king', tier: 5, stars: 4, background: 'åŒ—å¤§æ•°å­¦ç³»å­¦éœ¸', aiGenerated: false },
                    { name: 'æ¸…åå­¦éœ¸', personality: 'competitive', subject: 'cs', rankLevel: 'king', tier: 4, stars: 3, background: 'æ¸…åè®¡ç®—æœºç³»é«˜æ‰‹', aiGenerated: false },
                    { name: 'å¤æ—¦æ–‡è±ª', personality: 'shy', subject: 'politics', rankLevel: 'master', tier: 5, stars: 2, background: 'å¤æ—¦æ”¿æ²»å­¦ä¸“ä¸š', aiGenerated: false }
                ];
                
                gameData.virtualPlayers = [...basicPlayers];
                
                // AIç”Ÿæˆæ›´å¤šç©å®¶
                const generatePromises = [];
                for (let i = 0; i < 15; i++) { // å…ˆç”Ÿæˆ15ä¸ªAIç©å®¶
                    generatePromises.push(generateAIPlayer());
                }
                
                try {
                    const aiPlayers = await Promise.all(generatePromises);
                    gameData.virtualPlayers.push(...aiPlayers);
                    
                    // å¡«å……å‰©ä½™çš„éšæœºç©å®¶åˆ°100ä¸ª
                    while (gameData.virtualPlayers.length < 100) {
                        gameData.virtualPlayers.push(generateFallbackPlayer());
                    }
                    
                    showNotification('âœ… è™šæ‹Ÿç©å®¶ç”Ÿæˆå®Œæˆï¼åŒ…å«AIç”Ÿæˆç©å®¶');
                } catch (error) {
                    console.error('AIç©å®¶ç”Ÿæˆéƒ¨åˆ†å¤±è´¥:', error);
                    // å¡«å……åˆ°100ä¸ª
                    while (gameData.virtualPlayers.length < 100) {
                        gameData.virtualPlayers.push(generateFallbackPlayer());
                    }
                    showNotification('âš ï¸ è™šæ‹Ÿç©å®¶ç”Ÿæˆå®Œæˆï¼ˆéƒ¨åˆ†AIç”Ÿæˆå¤±è´¥ï¼‰');
                }
                
                // æ¯ä¸ªç©å®¶æ·»åŠ åŠ¨æ€å±æ€§
                gameData.virtualPlayers.forEach(player => {
                    if (!player.lastActive) player.lastActive = new Date().toISOString();
                    if (player.momentum === undefined) player.momentum = Math.random() * 2 - 1;
                    if (player.relationshipWithUser === undefined) player.relationshipWithUser = Math.random() * 2 - 1;
                });
            }
        }
        
        // AIéšæœºäº‹ä»¶ç”Ÿæˆ
        async function generateRandomEvents() {
            // éšæœºPKäº‹ä»¶ï¼ˆæ¯5åˆ†é’Ÿ20%æ¦‚ç‡ï¼‰
            if (Math.random() < 0.2) {
                await generatePKChallenge();
            }
            
            // AIå‰§æƒ…äº‹ä»¶ï¼ˆæ¯10åˆ†é’Ÿ15%æ¦‚ç‡ï¼‰
            if (Math.random() < 0.15) {
                await triggerAIStoryEvent();
            }
            
            // è™šæ‹Ÿç©å®¶åŠ¨æ€æ›´æ–°
            updateVirtualPlayers();
            
            // éšæœºç”Ÿæˆæ–°ç©å®¶ï¼ˆæ¯å°æ—¶5%æ¦‚ç‡ï¼‰
            if (Math.random() < 0.05 && gameData.virtualPlayers.length < 120) {
                try {
                    const newPlayer = await generateAIPlayer();
                    gameData.virtualPlayers.push(newPlayer);
                    showNotification(`ğŸ‘¥ æ–°ç©å®¶åŠ å…¥ï¼š${newPlayer.name} (${newPlayer.background})`);
                } catch (error) {
                    console.error('æ–°ç©å®¶ç”Ÿæˆå¤±è´¥:', error);
                }
            }
        }
        
        async function triggerAIStoryEvent() {
            try {
                const event = await generateAIStoryEvent();
                showChoiceModal(event);
                
                const aiTag = event.aiGenerated ? ' ğŸ¤–AIç”Ÿæˆ' : '';
                showNotification(`ğŸ­ å‰§æƒ…äº‹ä»¶ï¼š${event.title}${aiTag}`);
            } catch (error) {
                console.error('AIå‰§æƒ…äº‹ä»¶ç”Ÿæˆå¤±è´¥:', error);
                // é™çº§åˆ°ä¼ ç»Ÿå‰§æƒ…äº‹ä»¶
                triggerMinorStoryEvent();
            }
        }
        
        // è™šæ‹Ÿç©å®¶åŠ¨æ€æ›´æ–°ç³»ç»Ÿ
        function updateVirtualPlayers() {
            const now = new Date();
            
            gameData.virtualPlayers.forEach(player => {
                const lastActive = new Date(player.lastActive);
                const daysSinceActive = (now - lastActive) / (1000 * 60 * 60 * 24);
                
                // æ¯å¤©æœ‰30%æ¦‚ç‡æ›´æ–°ç©å®¶çŠ¶æ€
                if (daysSinceActive >= 1 && Math.random() < 0.3) {
                    // æ ¹æ®momentumè°ƒæ•´æ®µä½
                    if (player.momentum > 0.3 && Math.random() < 0.4) {
                        // è¿›æ­¥
                        if (player.stars < 5) {
                            player.stars++;
                        } else {
                            player.stars = 1;
                            if (player.tier > 1) {
                                player.tier--;
                            } else {
                                const rankOrder = ['bronze', 'silver', 'gold', 'platinum', 'diamond', 'master', 'king'];
                                const currentIndex = rankOrder.indexOf(player.rankLevel);
                                if (currentIndex < rankOrder.length - 1) {
                                    player.rankLevel = rankOrder[currentIndex + 1];
                                    player.tier = 5;
                                }
                            }
                        }
                    } else if (player.momentum < -0.3 && Math.random() < 0.2) {
                        // é€€æ­¥
                        if (player.stars > 1) {
                            player.stars--;
                        } else {
                            player.stars = 5;
                            if (player.tier < 5) {
                                player.tier++;
                            } else {
                                const rankOrder = ['bronze', 'silver', 'gold', 'platinum', 'diamond', 'master', 'king'];
                                const currentIndex = rankOrder.indexOf(player.rankLevel);
                                if (currentIndex > 0) {
                                    player.rankLevel = rankOrder[currentIndex - 1];
                                    player.tier = 1;
                                }
                            }
                        }
                    }
                    
                    // æ›´æ–°momentum
                    player.momentum += (Math.random() - 0.5) * 0.4;
                    player.momentum = Math.max(-1, Math.min(1, player.momentum));
                    
                    player.lastActive = now.toISOString();
                }
            });
        }
        
        // éšæœºå¥–åŠ±ç³»ç»Ÿï¼ˆå‡çº§ä¸ºAIç”Ÿæˆï¼‰
        async function giveRandomReward() {
            try {
                const reward = await generateAIReward('éšæœºå³æ—¶å¥–åŠ±');
                
                if (reward.type === 'è£…æ‰®' || reward.type === 'costume') {
                    gameData.inventory.push({
                        type: 'costume',
                        name: reward.name,
                        costume: reward.description,
                        aiGenerated: reward.aiGenerated
                    });
                } else if (reward.type === 'é“å…·' || reward.type === 'virtual') {
                    if (reward.name.includes('æŠ½å¡åˆ¸')) {
                        const amount = parseInt(reward.name.match(/\d+/)?.[0]) || 1;
                        gameData.cardCount += amount;
                    }
                    gameData.inventory.push({
                        type: 'virtual',
                        name: reward.name,
                        aiGenerated: reward.aiGenerated
                    });
                } else {
                    gameData.inventory.push(reward);
                }
                
                const aiTag = reward.aiGenerated ? ' ğŸ¤–' : '';
                showNotification(`ğŸ éšæœºå¥–åŠ±ï¼š${reward.name}ï¼${aiTag}`);
            } catch (error) {
                console.error('AIéšæœºå¥–åŠ±ç”Ÿæˆå¤±è´¥:', error);
                // é™çº§åˆ°ç®€å•å¥–åŠ±
                gameData.cardCount += 1;
                showNotification(`ğŸ éšæœºå¥–åŠ±ï¼šæŠ½å¡åˆ¸Ã—1ï¼`);
            }
        }
        
        // æŠ½å¡ç³»ç»Ÿï¼ˆAIå¢å¼ºï¼‰
        async function drawCard() {
            if (gameData.cardCount <= 0) {
                showNotification('æŠ½å¡åˆ¸ä¸è¶³ï¼', 'error');
                return;
            }
            
            gameData.cardCount--;
            
            try {
                const reward = await generateAIReward('æŠ½å¡è·å¾—');
                
                if (reward.type === 'è£…æ‰®' || reward.type === 'costume') {
                    gameData.inventory.push({
                        type: 'costume',
                        name: reward.name,
                        costume: reward.description,
                        aiGenerated: reward.aiGenerated
                    });
                } else {
                    gameData.inventory.push(reward);
                }
                
                const aiTag = reward.aiGenerated ? ' ğŸ¤–AIç”Ÿæˆ' : '';
                showNotification(`ğŸ´ æŠ½å¡è·å¾—ï¼š${reward.name}ï¼${aiTag}`);
                
                // è¯¢é—®æ˜¯å¦ç”Ÿæˆè£…æ‰®å›¾ç‰‡
                if ((reward.type === 'è£…æ‰®' || reward.type === 'costume') && reward.description) {
                    const shouldGenerate = confirm(`ğŸ¨ æ˜¯å¦ç”Ÿæˆå·å·ç©¿ç€ã€${reward.name}ã€‘çš„å›¾ç‰‡ï¼Ÿ`);
                    if (shouldGenerate) {
                        generateCatImage(reward.description);
                    }
                }
            } catch (error) {
                console.error('AIæŠ½å¡å¥–åŠ±ç”Ÿæˆå¤±è´¥:', error);
                // é™çº§å¥–åŠ±
                gameData.inventory.push({
                    type: 'virtual',
                    name: 'ç¥ç§˜ç¤¼åŒ…Ã—1',
                    aiGenerated: false
                });
                showNotification(`ğŸ´ æŠ½å¡è·å¾—ï¼šç¥ç§˜ç¤¼åŒ…Ã—1ï¼`);
            }
            
            updateUI();
            saveData();
        }
        
        function updateRewardPool() {
            const rewards = [
                'â–¸å·å·ã€å¥¶å’–å°æ¯›è¡£ã€‘è£…æ‰®',
                'â–¸èŒ¶ç™¾é“Â·èŒ‰è‰å¥¶ç»¿+èŠ‹æ³¥æ³¢æ³¢(å»å†°)',
                'â–¸æŠ½å¡åˆ¸Ã—1',
                'â–¸ç›²ç›’ï¼šå°å°å›æ¡ƒ(éšæœºæ¬¾)'
            ];
            
            const container = document.getElementById('rewardPool');
            container.innerHTML = rewards.map(reward => `
                <div class="reward-item">
                    <span>${reward}</span>
                    <button class="btn btn-primary" style="padding: 4px 8px; font-size: 12px;" 
                            onclick="claimReward('${reward}')">é¢†å–</button>
                </div>
            `).join('');
        }
        
        // ä»»åŠ¡ç›¸å…³åŠŸèƒ½
        function setupFileUpload() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            
            uploadArea.addEventListener('click', () => fileInput.click());
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });
            
            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFileUpload(files[0]);
                }
            });
            
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleFileUpload(e.target.files[0]);
                }
            });
        }
        
        async function handleFileUpload(file) {
            showNotification('æ­£åœ¨è¯†åˆ«ä»»åŠ¡æ¸…å•...è¯·ç¨ç­‰');
            
            // æ˜¾ç¤ºä¸Šä¼ çš„å›¾ç‰‡é¢„è§ˆ
            const reader = new FileReader();
            reader.onload = function(e) {
                const preview = document.createElement('div');
                preview.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    width: 200px;
                    background: white;
                    border-radius: 8px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                    z-index: 1000;
                    padding: 10px;
                `;
                preview.innerHTML = `
                    <div style="font-size: 12px; margin-bottom: 5px;">ğŸ“· ä»»åŠ¡æ¸…å•</div>
                    <img src="${e.target.result}" style="width: 100%; border-radius: 4px;">
                    <div style="font-size: 10px; color: #6b7280; margin-top: 5px;">æ­£åœ¨è¯†åˆ«ä¸­...</div>
                `;
                document.body.appendChild(preview);
                
                setTimeout(() => {
                    if (document.body.contains(preview)) {
                        document.body.removeChild(preview);
                    }
                }, 5000);
            };
            reader.readAsDataURL(file);
            
            try {
                // æ¨¡æ‹ŸAIè¯†åˆ«è¿‡ç¨‹ï¼ˆ2-4ç§’éšæœºå»¶è¿Ÿï¼‰
                const delay = 2000 + Math.random() * 2000;
                await new Promise(resolve => setTimeout(resolve, delay));
                
                // æ™ºèƒ½ç”Ÿæˆä»»åŠ¡åˆ—è¡¨ï¼ˆæ›´çœŸå®çš„æ¨¡æ‹Ÿï¼‰
                const taskTemplates = [
                    // æ•°å­¦ç±»
                    ['å®Œæˆçº¿æ€§ä»£æ•°ä¹ é¢˜ç¬¬3ç« 1-10é¢˜', 'å¤ä¹ æ¦‚ç‡è®ºçŸ¥è¯†ç‚¹ï¼šè´å¶æ–¯å®šç†', 'åˆ·é«˜ç­‰æ•°å­¦çœŸé¢˜2å¥—'],
                    ['å®Œæˆæ•°å­¦åˆ†æç»ƒä¹ é¢˜20é“', 'æ•´ç†å¾®ç§¯åˆ†å…¬å¼ç¬”è®°', 'åšå†å¹´çœŸé¢˜æ•°å­¦éƒ¨åˆ†'],
                    
                    // è‹±è¯­ç±»
                    ['èƒŒè¯µè€ƒç ”è¯æ±‡Day15ï¼ˆ150ä¸ªï¼‰', 'å®Œæˆè‹±è¯­é˜…è¯»ç†è§£4ç¯‡', 'å†™ä½œæ–‡1ç¯‡ï¼šç¯å¢ƒä¿æŠ¤è¯é¢˜'],
                    ['ç¿»è¯‘ç»ƒä¹ 2ç¯‡', 'èƒŒè¯µè‹±è¯­ä½œæ–‡æ¨¡æ¿', 'å¬åŠ›ç»ƒä¹ 30åˆ†é’Ÿ'],
                    
                    // ä¸“ä¸šè¯¾ç±»
                    ['å¤ä¹ è®¡ç®—æœºç½‘ç»œç¬¬4ç« ', 'æ•´ç†æ•°æ®ç»“æ„æ ‘çš„çŸ¥è¯†ç‚¹', 'ç¼–ç¨‹ç»ƒä¹ ï¼šäºŒå‰æ ‘éå†'],
                    ['çœ‹æ“ä½œç³»ç»Ÿè§†é¢‘è¯¾ç¨‹2å°æ—¶', 'åšè®¡ç®—æœºç»„æˆåŸç†é¢˜ç›®', 'å¤ä¹ æ•°æ®åº“è®¾è®¡èŒƒå¼'],
                    
                    // æ”¿æ²»ç±»
                    ['èƒŒè¯µé©¬åŸé‡ç‚¹æ¦‚å¿µ20ä¸ª', 'åšæ”¿æ²»é€‰æ‹©é¢˜100é“', 'æ•´ç†è¿‘ä»£å²æ—¶é—´è½´'],
                    ['å¤ä¹ æ¯›æ¦‚çŸ¥è¯†ç‚¹ï¼šç§‘å­¦å‘å±•è§‚', 'èƒŒè¯µæ”¿æ²»å¤§é¢˜ç­”é¢˜æ¨¡æ¿', 'åšæ—¶æ”¿é¢˜ç›®50é“'],
                    
                    // ç»¼åˆç±»
                    ['åˆ¶å®šæ˜æ—¥å­¦ä¹ è®¡åˆ’', 'æ•´ç†é”™é¢˜æœ¬', 'å¤ä¹ ä»Šæ—¥æ‰€å­¦å†…å®¹', 'é¢„ä¹ æ˜å¤©çš„è¯¾ç¨‹å†…å®¹']
                ];
                
                // éšæœºé€‰æ‹©ä»»åŠ¡ç»„åˆ
                const selectedTemplate = taskTemplates[Math.floor(Math.random() * taskTemplates.length)];
                const additionalTasks = taskTemplates[Math.floor(Math.random() * taskTemplates.length)];
                
                // ç»„åˆä»»åŠ¡ï¼Œç¡®ä¿æœ‰4-7ä¸ªä»»åŠ¡
                let allTasks = [...selectedTemplate];
                
                // éšæœºæ·»åŠ 1-3ä¸ªå…¶ä»–ä»»åŠ¡
                const extraCount = Math.floor(Math.random() * 3) + 1;
                for (let i = 0; i < extraCount; i++) {
                    const randomTask = additionalTasks[Math.floor(Math.random() * additionalTasks.length)];
                    if (!allTasks.includes(randomTask)) {
                        allTasks.push(randomTask);
                    }
                }
                
                // éšæœºæ‰“ä¹±é¡ºåº
                allTasks = allTasks.sort(() => Math.random() - 0.5);
                
                gameData.tasks = allTasks;
                gameData.completedTasks = [];
                gameData.lastTaskDate = new Date().toDateString();
                
                updateTaskList();
                saveData();
                showNotification(`âœ… ä»»åŠ¡è¯†åˆ«å®Œæˆï¼å…±è¯†åˆ«åˆ°${allTasks.length}ä¸ªä»»åŠ¡`);
                
                // è§¦å‘å‰§æƒ…äº‹ä»¶
                if (Math.random() < 0.3) {
                    setTimeout(() => {
                        triggerMinorStoryEvent();
                    }, 2000);
                }
                
            } catch (error) {
                console.error('ä»»åŠ¡è¯†åˆ«å¤±è´¥:', error);
                showNotification('âŒ ä»»åŠ¡è¯†åˆ«å¤±è´¥ï¼Œè¯·é‡æ–°ä¸Šä¼ ', 'error');
            }
        }
        
        function completeTask() {
            const input = document.getElementById('taskInput').value.trim().toLowerCase();
            const match = input.match(/^t(\d+)$/);
            
            if (!match) {
                showNotification('æ ¼å¼é”™è¯¯ï¼è¯·è¾“å…¥t1ã€t2ç­‰æ ¼å¼', 'error');
                return;
            }
            
            const taskIndex = parseInt(match[1]) - 1;
            
            if (taskIndex < 0 || taskIndex >= gameData.tasks.length) {
                showNotification('ä»»åŠ¡ç¼–å·ä¸å­˜åœ¨ï¼', 'error');
                return;
            }
            
            if (gameData.completedTasks.includes(taskIndex)) {
                showNotification('ä»»åŠ¡å·²å®Œæˆï¼', 'error');
                return;
            }
            
            // è·å–å½“å‰å­¦ä¹ æ—¶ç¨‹ä¿¡æ¯
            const currentSchedule = getCurrentScheduleInfo();
            const scheduleBonus = getScheduleBonus(currentSchedule);
            
            // åŸºç¡€å¥–åŠ±
            let powerGain = 20;
            let expGain = 25;
            
            // åº”ç”¨æ—¶ç¨‹åŠ æˆ
            powerGain = Math.round(powerGain * scheduleBonus.powerMultiplier);
            expGain = Math.round(expGain * scheduleBonus.expMultiplier);
            
            gameData.completedTasks.push(taskIndex);
            gameData.todayPower += powerGain;
            gameData.stats.totalTasksCompleted++;
            gameData.totalExp += expGain;
            gameData.lastTaskDate = new Date().toDateString();
            
            // ç‰¹æ®Šå¥–åŠ±
            if (scheduleBonus.specialReward) {
                gameData.inventory.push({
                    type: 'virtual',
                    name: scheduleBonus.specialReward
                });
            }
            
            // æ£€æŸ¥æ˜¯å¦è§£é”æ–°å¥–åŠ±
            checkAndGenerateRewards();
            
            // è°ƒæ•´éšæœºå¥–åŠ±æ¦‚ç‡ï¼ˆåŸºäºå­¦ä¹ æ•ˆç‡ï¼‰
            const bonusChance = 0.4 + (gameData.streakDays * 0.05) + ((scheduleBonus.powerMultiplier - 1) * 0.3);
            if (Math.random() < bonusChance) {
                giveRandomReward();
            }
            
            // æ£€æŸ¥æ˜¯å¦å‡çº§
            checkLevelUp();
            
            // æ£€æŸ¥æˆå°±
            checkAchievements();
            
            // æ›´æ–°å·å·å¿ƒæƒ…
            updateCatMood();
            
            updateUI();
            saveData();
            closeModal();
            
            // æ˜¾ç¤ºå¥–åŠ±ä¿¡æ¯
            let notificationText = `ä»»åŠ¡ ${input} å®Œæˆï¼+${powerGain}æˆ˜åŠ› +${expGain}ç»éªŒ`;
            if (scheduleBonus.specialReward) {
                notificationText += ` +${scheduleBonus.specialReward}`;
            }
            
            showNotification(notificationText, 'success');
            
            // æ˜¾ç¤ºæ—¶ç¨‹æé†’
            if (scheduleBonus.message) {
                setTimeout(() => {
                    showNotification(scheduleBonus.message);
                }, 1000);
            }
            
            document.getElementById('taskInput').value = '';
            
            // ä»»åŠ¡å®Œæˆç‰¹æ•ˆ
            showTaskCompleteEffect();
        }
        
        function showTaskCompleteEffect() {
            // åˆ›å»ºç²’å­ç‰¹æ•ˆ
            const effect = document.createElement('div');
            effect.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 24px;
                color: #10b981;
                pointer-events: none;
                z-index: 9999;
                animation: taskComplete 2s ease-out forwards;
            `;
            effect.textContent = 'âœ¨ ä»»åŠ¡å®Œæˆ! âœ¨';
            
            // æ·»åŠ CSSåŠ¨ç”»
            const style = document.createElement('style');
            style.textContent = `
                @keyframes taskComplete {
                    0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    50% { opacity: 1; transform: translate(-50%, -60%) scale(1.2); }
                    100% { opacity: 0; transform: translate(-50%, -70%) scale(1.5); }
                }
            `;
            document.head.appendChild(style);
            
            document.body.appendChild(effect);
            setTimeout(() => {
                document.body.removeChild(effect);
                document.head.removeChild(style);
            }, 2000);
        }
        
        function updateCatMood() {
            const completionRate = gameData.completedTasks.length / Math.max(gameData.tasks.length, 1);
            
            if (completionRate >= 0.8) {
                gameData.catMood = 'excited';
            } else if (completionRate >= 0.5) {
                gameData.catMood = 'happy';
            } else if (gameData.todayPower >= 40) {
                gameData.catMood = 'content';
            } else {
                gameData.catMood = 'hungry';
            }
        }
        
        function checkAchievements() {
            const newAchievements = [];
            
            // æ£€æŸ¥å„ç§æˆå°±
            if (gameData.stats.totalTasksCompleted >= 10 && !gameData.achievements.includes('first_ten')) {
                newAchievements.push({ id: 'first_ten', name: 'åˆå‡ºèŒ…åº', desc: 'ç´¯è®¡å®Œæˆ10ä¸ªä»»åŠ¡', reward: 'æŠ½å¡åˆ¸Ã—2' });
            }
            
            if (gameData.stats.totalTasksCompleted >= 50 && !gameData.achievements.includes('fifty_tasks')) {
                newAchievements.push({ id: 'fifty_tasks', name: 'å‹¤å¥‹å­¦è€…', desc: 'ç´¯è®¡å®Œæˆ50ä¸ªä»»åŠ¡', reward: 'å·å·ã€å‹¤å¥‹å¾½ç« ã€‘è£…æ‰®' });
            }
            
            if (gameData.streakDays >= 7 && !gameData.achievements.includes('week_streak')) {
                newAchievements.push({ id: 'week_streak', name: 'åšæŒä¸æ‡ˆ', desc: 'è¿ç»­å®Œæˆä»»åŠ¡7å¤©', reward: 'åŒå€ç»éªŒå¡(24å°æ—¶)' });
            }
            
            if (gameData.stats.pkWins >= 5 && !gameData.achievements.includes('pk_master')) {
                newAchievements.push({ id: 'pk_master', name: 'PKå¤§å¸ˆ', desc: 'èµ¢å¾—5åœºPKæŒ‘æˆ˜', reward: 'å·å·ã€èƒœåˆ©è€…å¤´å† ã€‘è£…æ‰®' });
            }
            
            if (gameData.ranking <= 100 && !gameData.achievements.includes('top_hundred')) {
                newAchievements.push({ id: 'top_hundred', name: 'ç™¾å¼ºç²¾è‹±', desc: 'æ’åè¿›å…¥å‰100', reward: 'å¨æœ›ä»¤ç‰ŒÃ—3' });
            }
            
            // æ˜¾ç¤ºæ–°æˆå°±
            newAchievements.forEach(achievement => {
                gameData.achievements.push(achievement.id);
                showAchievementModal(achievement);
                
                // ç»™äºˆå¥–åŠ±
                if (achievement.reward.includes('æŠ½å¡åˆ¸')) {
                    const amount = parseInt(achievement.reward.match(/\d+/)[0]);
                    gameData.cardCount += amount;
                } else if (achievement.reward.includes('è£…æ‰®')) {
                    gameData.inventory.push({
                        type: 'costume',
                        name: achievement.reward,
                        costume: 'æˆå°±å¥–åŠ±è£…æ‰®'
                    });
                } else {
                    gameData.inventory.push({
                        type: 'virtual',
                        name: achievement.reward
                    });
                }
            });
        }
        
        function showAchievementModal(achievement) {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header" style="background: linear-gradient(135deg, #fbbf24, #f59e0b); color: white;">
                        ğŸ† æˆå°±è§£é”ï¼
                    </div>
                    <div class="modal-body" style="text-align: center;">
                        <div style="font-size: 24px; margin: 20px 0;">ğŸ‰</div>
                        <div style="font-size: 18px; font-weight: bold; margin: 10px 0;">${achievement.name}</div>
                        <div style="margin: 10px 0; color: #6b7280;">${achievement.desc}</div>
                        <div style="background: #f0f9ff; padding: 10px; border-radius: 6px; margin: 15px 0;">
                            ğŸ å¥–åŠ±ï¼š${achievement.reward}
                        </div>
                        <button class="btn btn-primary" onclick="this.closest('.modal').remove()">å¤ªæ£’äº†ï¼</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        // æ£€æŸ¥å‡çº§
        function checkLevelUp() {
            const completedCount = gameData.completedTasks.length;
            const oldStars = gameData.rank.stars;
            
            // æ¯å®Œæˆ2ä¸ªä»»åŠ¡å‡1æ˜Ÿ
            if (completedCount % 2 === 0 && completedCount > 0) {
                gameData.rank.stars = Math.min(5, gameData.rank.stars + 1);
                
                // æ»¡æ˜Ÿå‡çº§
                if (gameData.rank.stars === 5) {
                    gameData.rank.stars = 1;
                    gameData.rank.tier = Math.max(1, gameData.rank.tier - 1);
                    
                    if (gameData.rank.tier === 0) {
                        // å‡æ®µä½
                        const levels = ['bronze', 'silver', 'gold', 'platinum', 'diamond', 'master', 'king'];
                        const currentIndex = levels.indexOf(gameData.rank.level);
                        if (currentIndex < levels.length - 1) {
                            gameData.rank.level = levels[currentIndex + 1];
                            gameData.rank.tier = 5;
                        }
                    }
                    
                    showNotification('ğŸ‰ æ®µä½æå‡ï¼è·å¾—å‡çº§å¥–åŠ±ï¼');
                    // å‡çº§å¿…å®šè·å¾—è£…æ‰®å¥–åŠ±
                    const upgradeReward = {
                        type: 'costume',
                        name: 'å·å·ã€å‡çº§åº†ç¥å¸½ã€‘è£…æ‰®',
                        costume: 'åº†ç¥å‡çº§çš„å°å¸½å­'
                    };
                    gameData.inventory.push(upgradeReward);
                    
                    const shouldGenerate = confirm(`ğŸ‰ å‡çº§æˆåŠŸï¼è·å¾—${upgradeReward.name}ï¼\n\næ˜¯å¦ç«‹å³ç”Ÿæˆå›¾ç‰‡ï¼Ÿ`);
                    if (shouldGenerate) {
                        generateCatImage(upgradeReward.costume);
                    }
                }
                
                // æå‡æ’å
                if (gameData.rank.stars > oldStars) {
                    gameData.ranking = Math.max(1, gameData.ranking - Math.floor(Math.random() * 50) - 10);
                }
            }
        }
        
        function giveRandomReward() {
            const rewards = [
                { type: 'card', amount: 1, name: 'æŠ½å¡åˆ¸Ã—1' },
                { type: 'costume', name: 'å·å·å¥¶å’–å°æ¯›è¡£è£…æ‰®' },
                { type: 'real', name: 'èŒ¶ç™¾é“Â·èŒ‰è‰å¥¶ç»¿+èŠ‹æ³¥æ³¢æ³¢(å»å†°)' }
            ];
            
            const reward = rewards[Math.floor(Math.random() * rewards.length)];
            
            if (reward.type === 'card') {
                gameData.cardCount += reward.amount;
            }
            
            gameData.inventory.push(reward);
            showNotification(`ğŸ è·å¾—å¥–åŠ±ï¼š${reward.name}ï¼`);
        }
        
        // æ¨¡æ€æ¡†åŠŸèƒ½
        function showTaskModal() {
            document.getElementById('taskModal').style.display = 'block';
        }
        
        function showPkModal() {
            if (gameData.pkChallenge) {
                document.getElementById('pkSection').style.display = 'block';
            } else {
                showNotification('å½“å‰æ²¡æœ‰PKæŒ‘æˆ˜ï¼Œè¯·ç¨åå†è¯•ï¼');
            }
        }
        
        function showSettings() {
            document.getElementById('apiKeyInput').value = gameData.settings.apiKey;
            document.getElementById('examDateInput').value = gameData.settings.examDate;
            document.getElementById('settingsModal').style.display = 'block';
        }
        
        function showAIHelper() {
            document.getElementById('aiModal').style.display = 'block';
        }
        
        function closeModal() {
            document.querySelectorAll('.modal').forEach(modal => {
                modal.style.display = 'none';
            });
        }
        
        function saveSettings() {
            gameData.settings.apiKey = document.getElementById('apiKeyInput').value;
            gameData.settings.examDate = document.getElementById('examDateInput').value;
            saveData();
            closeModal();
            showNotification('è®¾ç½®å·²ä¿å­˜ï¼');
        }
        
        // AIåŠ©æ‰‹åŠŸèƒ½ - çœŸå®è°ƒç”¨è±†åŒ…API
        async function sendToAI() {
            const input = document.getElementById('aiInput');
            const question = input.value.trim();
            
            if (!question) return;
            
            const chatHistory = document.getElementById('aiChatHistory');
            
            // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
            chatHistory.innerHTML += `
                <div style="margin: 10px 0; text-align: right;">
                    <div style="background: #4f46e5; color: white; padding: 8px 12px; border-radius: 12px; display: inline-block; max-width: 80%;">
                        ${question}
                    </div>
                </div>
            `;
            
            input.value = '';
            chatHistory.scrollTop = chatHistory.scrollHeight;
            
            // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
            const loadingId = 'loading-' + Date.now();
            chatHistory.innerHTML += `
                <div style="margin: 10px 0;" id="${loadingId}">
                    <div style="background: #f1f5f9; padding: 8px 12px; border-radius: 12px; display: inline-block;">
                        ğŸ± å·å·æ­£åœ¨æ€è€ƒä¸­...
                    </div>
                </div>
            `;
            chatHistory.scrollTop = chatHistory.scrollHeight;
            
            try {
                // è°ƒç”¨è±†åŒ…API
                const response = await callDoubaoAPI(question);
                
                // ç§»é™¤åŠ è½½çŠ¶æ€
                document.getElementById(loadingId).remove();
                
                // æ·»åŠ AIå›å¤
                chatHistory.innerHTML += `
                    <div style="margin: 10px 0;">
                        <div style="background: #f1f5f9; padding: 8px 12px; border-radius: 12px; display: inline-block; max-width: 80%;">
                            ğŸ± å·å·ï¼š${response}
                        </div>
                    </div>
                `;
                
            } catch (error) {
                // ç§»é™¤åŠ è½½çŠ¶æ€
                document.getElementById(loadingId).remove();
                
                // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
                chatHistory.innerHTML += `
                    <div style="margin: 10px 0;">
                        <div style="background: #fee2e2; color: #dc2626; padding: 8px 12px; border-radius: 12px; display: inline-block; max-width: 80%;">
                            ğŸ± å·å·ï¼šæŠ±æ­‰ï¼Œæˆ‘ç°åœ¨æœ‰ç‚¹ç´¯ï¼Œè¯·æ£€æŸ¥APIé…ç½®æˆ–ç¨åå†è¯•ï½
                        </div>
                    </div>
                `;
            }
            
            chatHistory.scrollTop = chatHistory.scrollHeight;
        }
        
        // è°ƒç”¨è±†åŒ…API
        async function callDoubaoAPI(question) {
            const apiKey = gameData.settings.apiKey;
            const endpointId = gameData.settings.endpointId || 'ep-20250921171945-t4wjq'; // ä½¿ç”¨ç”¨æˆ·æä¾›çš„æ¥å…¥ç‚¹IDä½œä¸ºé»˜è®¤å€¼
            
            if (!apiKey) {
                throw new Error('è¯·å…ˆåœ¨è®¾ç½®ä¸­é…ç½®è±†åŒ…API Key');
            }
            
            if (!endpointId || !endpointId.startsWith('ep-')) {
                throw new Error('è¯·å…ˆåœ¨è®¾ç½®ä¸­é…ç½®æ­£ç¡®çš„è±†åŒ…æ¥å…¥ç‚¹ID');
            }
            
            const apiUrl = 'https://ark.cn-beijing.volces.com/api/v3/chat/completions';
            
            const requestData = {
                model: endpointId,
                messages: [
                    {
                        role: 'system',
                        content: 'ä½ æ˜¯å·å·ï¼Œä¸€åªå¯çˆ±çš„æš¹ç½—çŒ«ï¼Œæ˜¯ç”¨æˆ·çš„è€ƒç ”å­¦ä¹ åŠ©æ‰‹ã€‚ä½ çš„å›ç­”è¦ç®€æ´å‹å¥½ï¼Œå……æ»¡é¼“åŠ±ï¼Œå¶å°”ç”¨ä¸€äº›å¯çˆ±çš„è¯­æ°”è¯ã€‚'
                    },
                    {
                        role: 'user',
                        content: question
                    }
                ],
                temperature: 0.7,
                max_tokens: 150
            };
            
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify(requestData)
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.status} - ${errorData.error?.message || 'æœªçŸ¥é”™è¯¯'}`);
            }
            
            const data = await response.json();
            return data.choices[0].message.content;
        }
        
        // ç”Ÿæˆå·å·è£…æ‰®å›¾ç‰‡
        async function generateCatImage(costume) {
            try {
                // æ„å»ºä¸­æ–‡æç¤ºè¯
                const chinesePrompt = `ä¸€åªå¯çˆ±çš„æš¹ç½—çŒ«ï¼Œç©¿ç€${costume}ï¼Œå¡é€šé£æ ¼ï¼Œç²¾ç¾ç»†èŠ‚ï¼Œæ¸©æŸ”çš„è¡¨æƒ…`;
                
                // ç¿»è¯‘ä¸ºè‹±æ–‡æç¤ºè¯
                const englishPrompt = await translatePrompt(chinesePrompt);
                
                // ç”Ÿæˆå›¾ç‰‡URL
                const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(englishPrompt)}?width=512&height=512&enhance=true&private=true&nologo=true&safe=true&model=flux`;
                
                // æ˜¾ç¤ºå›¾ç‰‡
                showCatImage(imageUrl, chinesePrompt);
                
            } catch (error) {
                console.error('ç”Ÿæˆå›¾ç‰‡å¤±è´¥:', error);
                showNotification('å›¾ç‰‡ç”Ÿæˆå¤±è´¥ï¼Œè¯·ç¨åå†è¯•', 'error');
            }
        }
        
        // ç¿»è¯‘æç¤ºè¯ï¼ˆä½¿ç”¨è±†åŒ…APIï¼‰
        async function translatePrompt(chinesePrompt) {
            try {
                const translation = await callDoubaoAPI(`è¯·å°†è¿™ä¸ªä¸­æ–‡æè¿°ç¿»è¯‘ä¸ºè‹±æ–‡ï¼Œç”¨äºAIå›¾åƒç”Ÿæˆï¼Œåªè¿”å›è‹±æ–‡ç»“æœï¼š${chinesePrompt}`);
                return translation;
            } catch (error) {
                // å¦‚æœAPIè°ƒç”¨å¤±è´¥ï¼Œä½¿ç”¨é¢„è®¾çš„è‹±æ–‡è¯æ±‡
                return `A cute Siamese cat, kawaii anime style, detailed fur texture, gentle expression, high quality`;
            }
        }
        
        // æ˜¾ç¤ºå·å·å›¾ç‰‡
        function showCatImage(imageUrl, prompt) {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">ğŸ± å·å·æ–°è£…æ‰®</div>
                    <div class="modal-body" style="text-align: center;">
                        <img src="${imageUrl}" alt="å·å·è£…æ‰®" style="max-width: 100%; border-radius: 8px; margin: 10px 0;">
                        <p style="font-size: 12px; color: #6b7280; margin: 10px 0;">${prompt}</p>
                        <button class="btn btn-primary" onclick="this.closest('.modal').remove()">å¤ªå¯çˆ±äº†ï¼</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        // å…¶ä»–æ¸¸æˆåŠŸèƒ½
        // æŠ½å¡ç³»ç»Ÿï¼ˆAIå¢å¼ºç‰ˆæœ¬ï¼‰
        async function drawCard() {
            if (gameData.cardCount <= 0) {
                showNotification('æŠ½å¡åˆ¸ä¸è¶³ï¼', 'error');
                return;
            }
            
            gameData.cardCount--;
            
            try {
                const reward = await generateAIReward('æŠ½å¡è·å¾—');
                
                if (reward.type === 'è£…æ‰®' || reward.type === 'costume') {
                    gameData.inventory.push({
                        type: 'costume',
                        name: reward.name,
                        costume: reward.description,
                        aiGenerated: reward.aiGenerated
                    });
                } else {
                    gameData.inventory.push(reward);
                }
                
                const aiTag = reward.aiGenerated ? ' ğŸ¤–AIç”Ÿæˆ' : '';
                showNotification(`ğŸ´ æŠ½å¡è·å¾—ï¼š${reward.name}ï¼${aiTag}`);
                
                // è¯¢é—®æ˜¯å¦ç”Ÿæˆè£…æ‰®å›¾ç‰‡
                if ((reward.type === 'è£…æ‰®' || reward.type === 'costume') && reward.description) {
                    const shouldGenerate = confirm(`ğŸ¨ æ˜¯å¦ç”Ÿæˆå·å·ç©¿ç€ã€${reward.name}ã€‘çš„å›¾ç‰‡ï¼Ÿ`);
                    if (shouldGenerate) {
                        generateCatImage(reward.description);
                    }
                }
            } catch (error) {
                console.error('AIæŠ½å¡å¥–åŠ±ç”Ÿæˆå¤±è´¥:', error);
                // é™çº§å¥–åŠ±
                gameData.inventory.push({
                    type: 'virtual',
                    name: 'ç¥ç§˜ç¤¼åŒ…Ã—1',
                    aiGenerated: false
                });
                showNotification(`ğŸ´ æŠ½å¡è·å¾—ï¼šç¥ç§˜ç¤¼åŒ…Ã—1ï¼`);
            }
            
            updateUI();
            saveData();
        }
        
        function generateFromInventory(index) {
            const item = gameData.inventory[index];
            if (item.type === 'costume' && (item.costume || item.description)) {
                generateCatImage(item.costume || item.description);
            }
        }
        
        // ä¼ ç»Ÿå‰§æƒ…äº‹ä»¶ï¼ˆä½œä¸ºAIç”Ÿæˆå¤±è´¥çš„å¤‡ç”¨ï¼‰
        function triggerMinorStoryEvent() {
            const events = [
                {
                    id: 'professor_visit',
                    title: 'é™ˆæ•™æˆçš„å…³å¿ƒ',
                    content: 'é™ˆæ•™æˆæ³¨æ„åˆ°äº†ä½ æœ€è¿‘çš„åŠªåŠ›ï¼Œç‰¹åœ°æ¥è¯¢é—®å­¦ä¹ æƒ…å†µã€‚',
                    choices: [
                        { text: 'æ±‡æŠ¥å­¦ä¹ è¿›åº¦', effect: () => { gameData.todayPower += 10; showNotification('é™ˆæ•™æˆå¾ˆæ»¡æ„ä½ çš„è¿›åº¦ï¼+10æˆ˜åŠ›'); } },
                        { text: 'è¯·æ•™å­¦ä¹ æ–¹æ³•', effect: () => { gameData.inventory.push({type: 'virtual', name: 'å­¦ä¹ æ–¹æ³•æŒ‡å—'}); showNotification('è·å¾—å­¦ä¹ æ–¹æ³•æŒ‡å—ï¼'); } }
                    ],
                    aiGenerated: false
                },
                {
                    id: 'cat_discovery',
                    title: 'å·å·çš„å°ç§˜å¯†',
                    content: 'ä½ å‘ç°å·å·å·å·åœ¨çœ‹ä½ çš„å­¦ä¹ èµ„æ–™ï¼Œä¼¼ä¹æƒ³è¦å¸®åŠ©ä½ ã€‚',
                    choices: [
                        { text: 'å’Œå·å·ä¸€èµ·å­¦ä¹ ', effect: () => { gameData.catMood = 'happy'; gameData.inventory.push({type: 'costume', name: 'å·å·ã€å­¦ä¹ ä¼™ä¼´å¾½ç« ã€‘è£…æ‰®', costume: 'ä»£è¡¨å‹è°Šçš„å°å¾½ç« '}); showNotification('å·å·å¾ˆå¼€å¿ƒï¼è·å¾—å‹è°Šå¾½ç« ï¼'); } },
                        { text: 'ç»™å·å·å°é›¶é£Ÿ', effect: () => { gameData.catMood = 'excited'; gameData.todayPower += 5; showNotification('å·å·å¾ˆå…´å¥‹ï¼+5æˆ˜åŠ›'); } }
                    ],
                    aiGenerated: false
                }
            ];
            
            const availableEvents = events.filter(event => {
                if (event.id === 'professor_visit') return gameData.stats.totalTasksCompleted >= 5;
                return true;
            });
            
            if (availableEvents.length > 0 && Math.random() < 0.3) {
                const event = availableEvents[Math.floor(Math.random() * availableEvents.length)];
                showChoiceModal(event);
            }
        }
        
        // PKç³»ç»Ÿå¢å¼º
        function generateRandomEvents() {
            // éšæœºPKäº‹ä»¶ï¼ˆæ¯5åˆ†é’Ÿ20%æ¦‚ç‡ï¼‰
            if (Math.random() < 0.2) {
                generatePKChallenge();
            }
            
            // éšæœºå‰§æƒ…äº‹ä»¶ï¼ˆæ¯10åˆ†é’Ÿ10%æ¦‚ç‡ï¼‰
            if (Math.random() < 0.1) {
                triggerStoryEvent();
            }
            
            // è™šæ‹Ÿç©å®¶åŠ¨æ€æ›´æ–°
            updateVirtualPlayers();
        }
        
        async function generatePKChallenge() {
            if (gameData.pkChallenge) return; // å·²æœ‰PKæŒ‘æˆ˜
            
            initializeVirtualPlayers();
            
            // é€‰æ‹©ä¸€ä¸ªä¸ç”¨æˆ·æ®µä½ç›¸è¿‘çš„ç©å®¶
            const userRankValue = getRankValue(gameData.rank.level, gameData.rank.tier, gameData.rank.stars);
            const suitablePlayers = gameData.virtualPlayers.filter(player => {
                const playerRankValue = getRankValue(player.rankLevel, player.tier, player.stars);
                return Math.abs(playerRankValue - userRankValue) <= 300; // æ®µä½å·®è·ä¸è¶…è¿‡300åˆ†
            });
            
            if (suitablePlayers.length === 0) return;
            
            const opponent = suitablePlayers[Math.floor(Math.random() * suitablePlayers.length)];
            const ranks = { bronze: 'é’é“œ', silver: 'ç™½é“¶', gold: 'é»„é‡‘', platinum: 'é“‚é‡‘', diamond: 'é’»çŸ³', master: 'æ˜Ÿè€€', king: 'ç‹è€…' };
            const romanNumerals = ['', 'â… ', 'â…¡', 'â…¢', 'â…£', 'â…¤'];
            
            // ä½¿ç”¨AIç”Ÿæˆä¸ªæ€§åŒ–å¯¹è¯
            const dialogues = await getPersonalityDialogue(opponent.personality, opponent.relationshipWithUser);
            const taunt = dialogues[0];
            
            // ç”ŸæˆPKä»»åŠ¡
            const pkTasks = [
                { task: '20åˆ†é’Ÿå†…å®Œæˆ10é“æ•°å­¦é¢˜', timeLimit: 20, difficulty: 'medium' },
                { task: '30åˆ†é’Ÿå†…èƒŒè¯µ50ä¸ªè‹±è¯­å•è¯', timeLimit: 30, difficulty: 'hard' },
                { task: '15åˆ†é’Ÿå†…æ•´ç†ä¸€é¡µç¬”è®°', timeLimit: 15, difficulty: 'easy' },
                { task: '1å°æ—¶å†…å®Œæˆä¸€å¥—çœŸé¢˜', timeLimit: 60, difficulty: 'hard' },
                { task: '25åˆ†é’Ÿå†…å¤ä¹ ä¸€ä¸ªçŸ¥è¯†ç‚¹', timeLimit: 25, difficulty: 'medium' },
                { task: '40åˆ†é’Ÿå†…åˆ·å®Œä¸“ä¸šè¯¾ç»ƒä¹ ', timeLimit: 40, difficulty: 'medium' },
                { task: '35åˆ†é’Ÿå†…å®Œæˆè‹±è¯­é˜…è¯»4ç¯‡', timeLimit: 35, difficulty: 'hard' }
            ];
            
            const selectedTask = pkTasks[Math.floor(Math.random() * pkTasks.length)];
            
            gameData.pkChallenge = {
                opponent: opponent,
                task: selectedTask,
                taunt: taunt,
                startTime: new Date().toISOString(),
                displayRank: `${ranks[opponent.rankLevel]}${romanNumerals[opponent.tier]}`,
                displayStars: 'â˜…'.repeat(opponent.stars) + 'â˜†'.repeat(5 - opponent.stars)
            };
            
            showPKChallenge(gameData.pkChallenge);
        }
        
        function getRankValue(level, tier, stars) {
            const levelValues = { bronze: 0, silver: 500, gold: 1000, platinum: 1500, diamond: 2000, master: 2500, king: 3000 };
            return levelValues[level] + (6 - tier) * 100 + stars * 20;
        }
        
        // AIç”Ÿæˆä¸ªæ€§åŒ–å¯¹è¯
        async function getPersonalityDialogue(personality, relationship) {
            const relationshipText = relationship > 0.5 ? 'å‹å¥½' : 
                                   relationship < -0.5 ? 'æ•Œå¯¹' : 'ä¸­æ€§';
            
            const prompt = `ä½ æ˜¯ä¸€ä¸ªè€ƒç ”å­¦ä¹ æ¸¸æˆä¸­çš„è™šæ‹Ÿç©å®¶ï¼Œæ€§æ ¼æ˜¯${personality}ï¼Œå¯¹ç”¨æˆ·çš„æ€åº¦æ˜¯${relationshipText}çš„ã€‚
            ç°åœ¨è¦å¯¹ç”¨æˆ·å‘èµ·PKæŒ‘æˆ˜ï¼Œè¯·ç”Ÿæˆä¸€å¥ç®€çŸ­çš„æŒ‘è¡…æˆ–é¼“åŠ±çš„è¯ï¼Œè¦ç¬¦åˆä½ çš„æ€§æ ¼ç‰¹ç‚¹ã€‚
            
            æ€§æ ¼è¯´æ˜ï¼š
            - confident: è‡ªä¿¡ã€æœ‰ç‚¹å‚²æ…¢
            - shy: å®³ç¾ã€ä¸å–„è¡¨è¾¾
            - aggressive: å¥½æ–—ã€ç›´æ¥
            - supportive: æ”¯æŒã€é¼“åŠ±
            - silent: æ²‰é»˜å¯¡è¨€
            - sarcastic: è®½åˆºã€å°–é”
            - cheerful: å¼€æœ—ã€æ´»æ³¼
            - competitive: ç«äº‰å¿ƒå¼º
            
            è¦æ±‚ï¼š
            1. ä¸€å¥è¯ï¼Œä¸è¶…è¿‡20å­—
            2. ç¬¦åˆæ€§æ ¼å’Œå…³ç³»
            3. è‡ªç„¶å£è¯­åŒ–
            4. ä¸è¦é‡å¤å¸¸è§å¥—è¯`;
            
            try {
                const dialogue = await callDoubaoAPI(prompt);
                return [dialogue.replace(/["""]/g, '')]; // è¿”å›æ•°ç»„æ ¼å¼ä¿æŒå…¼å®¹
            } catch (error) {
                console.error('AIå¯¹è¯ç”Ÿæˆå¤±è´¥:', error);
                // é™çº§åˆ°é¢„è®¾å¯¹è¯
                return getFallbackDialogue(personality, relationship);
            }
        }
        
        function getFallbackDialogue(personality, relationship) {
            const dialogues = {
                confident: relationship > 0 ? 
                    ['å…„å¼Ÿï¼Œè¿™æ¬¡æ¯”æ‹¼åº”è¯¥å¾ˆç²¾å½©ï¼', 'æ¥å§ï¼Œè®©æˆ‘ä»¬åˆ‡ç£‹ä¸€ä¸‹ï¼', 'ä½ çš„å®åŠ›æˆ‘è®¤å¯ï¼Œå…¨åŠ›ä»¥èµ´å§ï¼'] :
                    ['å“¼ï¼Œå°±ä½ è¿™æ°´å¹³ä¹Ÿæ•¢æŒ‘æˆ˜æˆ‘ï¼Ÿ', 'æˆ‘é—­ç€çœ¼éƒ½èƒ½èµ¢ä½ ï¼', 'å‡†å¤‡å¥½è¢«ç¢¾å‹å§ï¼'],
                
                shy: relationship > 0 ?
                    ['ä¸€èµ·åŠ æ²¹å§...', 'æˆ‘ä»¬äº’ç›¸é¼“åŠ±ï½', 'å¸Œæœ›èƒ½å’Œä½ ä¸€èµ·è¿›æ­¥'] :
                    ['ä¸å¥½æ„æ€...æˆ‘ä¼šå°½åŠ›çš„', 'å¸Œæœ›è¿™æ¬¡èƒ½è¡¨ç°å¥½ä¸€ç‚¹...', '...'],
                
                aggressive: relationship > 0 ?
                    ['è¿™æ¬¡æˆ‘ä¸ä¼šæ‰‹ä¸‹ç•™æƒ…ï¼', 'æ¥å§ï¼å…¨åŠ›ä¸€æˆ˜ï¼', 'è®©æˆ‘çœ‹çœ‹ä½ çš„çœŸå®å®åŠ›ï¼'] :
                    ['å‡†å¤‡å¥½è¢«æˆ‘ç‹ ç‹ æ•™è®­å§ï¼', 'ä½ æ ¹æœ¬ä¸æ˜¯æˆ‘çš„å¯¹æ‰‹ï¼', 'æˆ‘è¦è®©ä½ çŸ¥é“ä»€ä¹ˆå«å·®è·ï¼'],
                
                supportive: relationship > 0 ?
                    ['ä¸€èµ·åŠªåŠ›ï¼Œäº’ç›¸è¿›æ­¥ï¼', 'æ— è®ºè¾“èµ¢ï¼Œæˆ‘ä»¬éƒ½æ˜¯å¥½æœ‹å‹ï¼', 'æ¯”èµ›æ„‰å¿«ï½'] :
                    ['åŠ æ²¹ï¼Œæˆ‘ç›¸ä¿¡ä½ èƒ½è¡Œçš„ï¼', 'å°½åŠ›å°±å¥½ï¼Œåˆ«æœ‰å‹åŠ›ï¼', 'æˆ‘ä»¬éƒ½åœ¨åŠªåŠ›å‘¢ï½'],
                
                silent: ['...', '(ç‚¹å¤´)', '(æ²‰é»˜åœ°å‡†å¤‡ç€)'],
                
                sarcastic: relationship > 0 ?
                    ['å“Ÿï¼Œåˆè§é¢äº†å‘¢ï½', 'è¿™æ¬¡å¯åˆ«è®©æˆ‘å¤ªå¤±æœ›å“¦', 'æœ‰ç‚¹æ„æ€ï¼Œæ¥ç©ç©å§'] :
                    ['å“¦è±ï¼Œè¿™ä¸æ˜¯é‚£ä¸ªè°å—ï¼Ÿ', 'åˆæ¥é€äººå¤´äº†ï¼Ÿ', 'æˆ‘åŠä½ è¿˜æ˜¯ç®—äº†å§ï½'],
                
                cheerful: relationship > 0 ?
                    ['å¤ªå¥½äº†ï¼åˆèƒ½å’Œä½ æ¯”èµ›äº†ï¼', 'åŠ æ²¹åŠ æ²¹ï¼æˆ‘ä»¬ä¸€èµ·å†²ï¼', 'å“‡ï¼å¥½å…´å¥‹å•Šï¼'] :
                    ['å˜¿å˜¿ï¼Œå‡†å¤‡å¥½äº†å—ï¼Ÿ', 'ä¸è¦ç´§å¼ ï¼Œå½“ä½œæ¸¸æˆå°±å¥½ï¼', 'æ”¾æ¾ç‚¹ï¼Œäº«å—æ¯”èµ›ï¼'],
                
                competitive: relationship > 0 ?
                    ['è¿™æ¬¡æˆ‘ä¸€å®šè¦èµ¢ä½ ï¼', 'æˆ‘å·²ç»å‡†å¤‡å¾ˆä¹…äº†ï¼', 'è®©æˆ‘çœ‹çœ‹è°æ›´å¼ºï¼'] :
                    ['æˆ‘ä¸ä¼šè®¤è¾“çš„ï¼', 'è¿™æ¬¡ä¸€å®šè¦åˆ†å‡ºèƒœè´Ÿï¼', 'ä½ å·²ç»è¾“å®šäº†ï¼']
            };
            
            return dialogues[personality] || ['å‡†å¤‡å¥½äº†å—ï¼Ÿ', 'æ¥æ¯”è¯•ä¸€ä¸‹å§ï¼', 'å…¨åŠ›ä»¥èµ´ï¼'];
        }
        
        // AIç”ŸæˆPKåååº”
        async function getPostBattleReaction(personality, result, opponentName) {
            const prompt = `ä½ æ˜¯è€ƒç ”å­¦ä¹ æ¸¸æˆä¸­çš„è™šæ‹Ÿç©å®¶"${opponentName}"ï¼Œæ€§æ ¼æ˜¯${personality}ã€‚
            åˆšåˆšå’Œç”¨æˆ·è¿›è¡Œäº†PKå¯¹æˆ˜ï¼Œç»“æœæ˜¯${result === 'user_win' ? 'ä½ è¾“äº†' : result === 'draw' ? 'å¹³å±€' : 'ä½ èµ¢äº†'}ã€‚
            
            è¯·ç”Ÿæˆä¸€å¥èµ›åæ„Ÿè¨€ï¼Œè¦ç¬¦åˆä½ çš„æ€§æ ¼ç‰¹ç‚¹ï¼š
            - confident: è‡ªä¿¡çš„
            - shy: å®³ç¾çš„  
            - aggressive: å¥½æ–—çš„
            - supportive: æ”¯æŒçš„
            - silent: æ²‰é»˜çš„
            - sarcastic: è®½åˆºçš„
            - cheerful: å¼€æœ—çš„
            - competitive: ç«äº‰å¿ƒå¼ºçš„
            
            è¦æ±‚ï¼š
            1. ä¸€å¥è¯ï¼Œä¸è¶…è¿‡15å­—
            2. ç¬¦åˆæ€§æ ¼å’Œæ¯”èµ›ç»“æœ
            3. è‡ªç„¶å£è¯­åŒ–`;
            
            try {
                const reaction = await callDoubaoAPI(prompt);
                return [reaction.replace(/["""]/g, '')];
            } catch (error) {
                console.error('AIååº”ç”Ÿæˆå¤±è´¥:', error);
                return getFallbackReactions(personality, result);
            }
        }
        
        function getFallbackReactions(personality, result) {
            const reactions = {
                confident: {
                    user_win: ['ä¸é”™å˜›ï¼Œè¿™æ¬¡ç®—ä½ èµ¢äº†ï¼', 'æ²¡æƒ³åˆ°ä½ è¿˜æŒºæœ‰å®åŠ›çš„', 'ä¸‹æ¬¡æˆ‘ä¸ä¼šå†è¾“äº†ï¼'],
                    draw: ['åŠ¿å‡åŠ›æ•Œï¼Œæœ‰è¶£ï¼', 'è¿™æ¬¡ç®—å¹³æ‰‹å§', 'çœ‹æ¥æˆ‘ä»¬å®åŠ›å·®ä¸å¤šå‘¢'],
                    user_loss: ['å“ˆå“ˆï¼Œæˆ‘å°±è¯´å˜›ï¼', 'è¿™æ‰æ˜¯æ­£å¸¸ç»“æœ', 'æˆ‘çš„å®åŠ›ä½ è¿˜æ˜¯çœ‹æ¸…æ¥šäº†å§']
                },
                shy: {
                    user_win: ['ä½ å¥½å‰å®³...', 'æˆ‘è¿˜éœ€è¦å¤šåŠªåŠ›...', 'æ­å–œä½ ...'],
                    draw: ['æˆ‘ä»¬éƒ½å¾ˆåŠªåŠ›å‘¢...', 'å¤§å®¶éƒ½åŠ æ²¹...', 'ä¸‹æ¬¡ç»§ç»­åŠªåŠ›...'],
                    user_loss: ['ä¸å¥½æ„æ€...', 'æˆ‘è¿™æ¬¡è¿æ°”æ¯”è¾ƒå¥½...', 'ä½ å·²ç»å¾ˆæ£’äº†...']
                }
                // ... å…¶ä»–æ€§æ ¼çš„ååº”
            };
            
            return reactions[personality]?.[result] || ['å¥½çš„æ¯”èµ›ï¼', 'ä¸‹æ¬¡å†æ¥ï¼', 'ç»§ç»­åŠªåŠ›ï¼'];
        }
        
        function showPKChallenge(pkData) {
            const pkSection = document.getElementById('pkSection');
            const pkCard = document.getElementById('pkCard');
            
            const timeIcon = pkData.task.difficulty === 'easy' ? 'âš¡' : pkData.task.difficulty === 'medium' ? 'â°' : 'ğŸ”¥';
            const opponentIcon = getOpponentIcon(pkData.opponent.personality);
            
            pkCard.innerHTML = `
                <div class="pk-player">${opponentIcon}ã€${pkData.opponent.name}ã€‘${pkData.displayRank} ${pkData.displayStars}</div>
                <div style="margin: 8px 0; padding: 8px; background: rgba(255,255,255,0.7); border-radius: 6px;">
                    ğŸ’¬"${pkData.taunt}"
                </div>
                <div class="pk-task">
                    ${timeIcon}PKä»»åŠ¡ï¼š${pkData.task.task}
                    <div style="font-size: 12px; color: #6b7280; margin-top: 4px;">
                        éš¾åº¦ï¼š${pkData.task.difficulty === 'easy' ? 'ç®€å•' : pkData.task.difficulty === 'medium' ? 'ä¸­ç­‰' : 'å›°éš¾'} | 
                        æ—¶é™ï¼š${pkData.task.timeLimit}åˆ†é’Ÿ
                    </div>
                </div>
                <div style="margin-top: 10px;">
                    <button class="btn btn-primary" onclick="acceptPK()" style="margin-right: 8px;">æ¥å—æŒ‘æˆ˜</button>
                    <button class="btn btn-secondary" onclick="ignorePK()">å¿½ç•¥</button>
                </div>
            `;
            
            pkSection.style.display = 'block';
            
            // 3åˆ†é’Ÿåè‡ªåŠ¨æ¶ˆå¤±
            setTimeout(() => {
                if (gameData.pkChallenge && !gameData.pkChallenge.accepted) {
                    ignorePK();
                }
            }, 3 * 60 * 1000);
        }
        
        function getOpponentIcon(personality) {
            const icons = {
                confident: 'ğŸ‘‘', shy: 'ğŸ°', aggressive: 'ğŸ”¥', supportive: 'ğŸŒŸ',
                silent: 'ğŸ—¿', sarcastic: 'ğŸ˜', cheerful: 'ğŸ˜Š', competitive: 'âš”ï¸',
                genius: 'ğŸ§ ', persistent: 'ğŸ’ª', efficient: 'âš¡', night_owl: 'ğŸ¦‰'
            };
            return icons[personality] || 'ğŸ¯';
        }
        
        async function acceptPK() {
            if (!gameData.pkChallenge) return;
            
            gameData.pkChallenge.accepted = true;
            gameData.pkChallenge.acceptedTime = new Date().toISOString();
            
            showNotification('PKæŒ‘æˆ˜å·²æ¥å—ï¼æ­£åœ¨è¿›è¡Œæ¿€çƒˆå¯¹æˆ˜...');
            document.getElementById('pkSection').style.display = 'none';
            
            // æ¨¡æ‹ŸPKç»“æœï¼ˆåŸºäºå¤šç§å› ç´ ï¼‰
            setTimeout(async () => {
                await resolvePK();
            }, 2000); // 2ç§’åæ˜¾ç¤ºç»“æœ
        }
        
        async function resolvePK() {
            if (!gameData.pkChallenge || !gameData.pkChallenge.accepted) return;
            
            const opponent = gameData.pkChallenge.opponent;
            const task = gameData.pkChallenge.task;
            
            // è®¡ç®—èƒœè´Ÿæ¦‚ç‡ï¼ˆåŸºäºå¤šç§å› ç´ ï¼‰
            let userWinChance = 0.4; // åŸºç¡€40%èƒœç‡
            
            // åŸºäºæ®µä½å·®è·è°ƒæ•´
            const userRankValue = getRankValue(gameData.rank.level, gameData.rank.tier, gameData.rank.stars);
            const opponentRankValue = getRankValue(opponent.rankLevel, opponent.tier, opponent.stars);
            const rankDiff = userRankValue - opponentRankValue;
            userWinChance += rankDiff / 1000 * 0.2; // æ®µä½ä¼˜åŠ¿
            
            // åŸºäºå½“å‰çŠ¶æ€è°ƒæ•´
            userWinChance += gameData.todayPower / 100 * 0.2; // æˆ˜åŠ›åŠ æˆ
            userWinChance += gameData.streakDays * 0.05; // è¿èƒœåŠ æˆ
            userWinChance += (gameData.completedTasks.length / Math.max(gameData.tasks.length, 1)) * 0.1; // å®Œæˆåº¦åŠ æˆ
            
            // åŸºäºä»»åŠ¡éš¾åº¦è°ƒæ•´
            if (task.difficulty === 'easy') userWinChance += 0.1;
            else if (task.difficulty === 'hard') userWinChance -= 0.1;
            
            // åŸºäºå…³ç³»è°ƒæ•´
            if (opponent.relationshipWithUser > 0.5) userWinChance += 0.05; // å‹å¥½å…³ç³»ï¼Œå¯¹æ–¹å¯èƒ½è®©ç€
            else if (opponent.relationshipWithUser < -0.5) userWinChance -= 0.05; // æ•Œå¯¹å…³ç³»ï¼Œå¯¹æ–¹æ›´æ‹¼
            
            // åŸºäºå­¦ä¹ æ—¶ç¨‹è°ƒæ•´
            const currentSchedule = getCurrentScheduleInfo();
            if (currentSchedule.type === 'study' && currentSchedule.efficiency >= 1.0) {
                userWinChance += 0.1; // å­¦ä¹ æ—¶é—´æ®µåŠ æˆ
            }
            
            // é™åˆ¶åœ¨10%-90%ä¹‹é—´
            userWinChance = Math.max(0.1, Math.min(0.9, userWinChance));
            
            const random = Math.random();
            let result, resultText, rewardText = '';
            
            if (random < userWinChance) {
                // èƒœåˆ©
                result = 'win';
                resultText = 'ğŸ‰ èƒœåˆ©ï¼';
                gameData.stats.pkWins++;
                gameData.rank.stars = Math.min(5, gameData.rank.stars + 1);
                gameData.ranking = Math.max(1, gameData.ranking - Math.floor(Math.random() * 20) - 5);
                
                // èƒœåˆ©å¥–åŠ±
                const winRewards = ['æŠ½å¡åˆ¸Ã—2', 'åŒå€ç»éªŒå¡(6å°æ—¶)', 'å¨æœ›ä»¤ç‰Œ'];
                const reward = winRewards[Math.floor(Math.random() * winRewards.length)];
                gameData.inventory.push({ type: 'virtual', name: reward });
                rewardText = `è·å¾—å¥–åŠ±ï¼š${reward}`;
                
                // æ”¹å–„å…³ç³»
                opponent.relationshipWithUser += 0.1;
                
            } else if (random < userWinChance + 0.15) {
                // å¹³å±€
                result = 'draw';
                resultText = 'ğŸ¤ å¹³å±€ï¼';
                gameData.stats.pkDraws++;
                
                // å¹³å±€å°å¥–åŠ±
                gameData.inventory.push({ type: 'virtual', name: 'æŠ½å¡åˆ¸Ã—1' });
                rewardText = 'è·å¾—å®‰æ…°å¥–ï¼šæŠ½å¡åˆ¸Ã—1';
                
            } else {
                // å¤±è´¥
                result = 'loss';
                resultText = 'ğŸ˜” å¤±è´¥...';
                gameData.stats.pkLosses++;
                
                // å¤±è´¥æƒ©ç½š
                if (gameData.rank.stars > 1) {
                    gameData.rank.stars--;
                } else if (gameData.rank.tier < 5) {
                    gameData.rank.stars = 5;
                    gameData.rank.tier++;
                }
                gameData.ranking = Math.min(10000, gameData.ranking + Math.floor(Math.random() * 15) + 5);
                
                // æ¶åŒ–å…³ç³»
                opponent.relationshipWithUser -= 0.05;
            }
            
            // è®°å½•PKå†å²
            gameData.pkHistory.unshift({
                opponent: opponent.name,
                result: result,
                task: task.task,
                date: new Date().toISOString()
            });
            
            // ä¿æŒæœ€è¿‘10æ¬¡è®°å½•
            if (gameData.pkHistory.length > 10) {
                gameData.pkHistory = gameData.pkHistory.slice(0, 10);
            }
            
            // æ˜¾ç¤ºç»“æœï¼ˆå¼‚æ­¥ï¼‰
            await showPKResult(resultText, rewardText, opponent);
            
            // æ¸…é™¤PKæŒ‘æˆ˜
            gameData.pkChallenge = null;
            
            updateUI();
            saveData();
        }
        
        async function showPKResult(resultText, rewardText, opponent) {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            
            const resultColor = resultText.includes('èƒœåˆ©') ? '#10b981' : 
                               resultText.includes('å¹³å±€') ? '#f59e0b' : '#ef4444';
            
            // ä½¿ç”¨AIç”Ÿæˆå¯¹æ‰‹ååº”
            const resultType = resultText.includes('èƒœåˆ©') ? 'user_win' : 
                              resultText.includes('å¹³å±€') ? 'draw' : 'user_loss';
            
            let reaction = 'å¥½çš„æ¯”èµ›ï¼';
            try {
                const reactions = await getPostBattleReaction(opponent.personality, resultType, opponent.name);
                reaction = reactions[0];
            } catch (error) {
                console.error('AIååº”ç”Ÿæˆå¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤ååº”');
                const fallbackReactions = getFallbackReactions(opponent.personality, resultType);
                reaction = fallbackReactions[Math.floor(Math.random() * fallbackReactions.length)];
            }
            
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header" style="background: ${resultColor}; color: white;">
                        PKç»“æœ
                    </div>
                    <div class="modal-body" style="text-align: center;">
                        <div style="font-size: 24px; margin: 20px 0;">${resultText}</div>
                        <div style="margin: 15px 0; padding: 10px; background: #f1f5f9; border-radius: 8px;">
                            <strong>${opponent.name}ï¼š</strong>"${reaction}"
                        </div>
                        ${rewardText ? `<div style="color: #059669; margin: 10px 0;">ğŸ ${rewardText}</div>` : ''}
                        <div style="font-size: 12px; color: #6b7280; margin-top: 10px;">
                            ğŸ’¡ å¯¹è¯ç”±è±†åŒ…AIå®æ—¶ç”Ÿæˆ
                        </div>
                        <button class="btn btn-primary" onclick="this.closest('.modal').remove()">ç¡®å®š</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        function getPostBattleReaction(personality, result) {
            const reactions = {
                confident: {
                    user_win: ['ä¸é”™å˜›ï¼Œè¿™æ¬¡ç®—ä½ èµ¢äº†ï¼', 'æ²¡æƒ³åˆ°ä½ è¿˜æŒºæœ‰å®åŠ›çš„', 'ä¸‹æ¬¡æˆ‘ä¸ä¼šå†è¾“äº†ï¼'],
                    draw: ['åŠ¿å‡åŠ›æ•Œï¼Œæœ‰è¶£ï¼', 'è¿™æ¬¡ç®—å¹³æ‰‹å§', 'çœ‹æ¥æˆ‘ä»¬å®åŠ›å·®ä¸å¤šå‘¢'],
                    user_loss: ['å“ˆå“ˆï¼Œæˆ‘å°±è¯´å˜›ï¼', 'è¿™æ‰æ˜¯æ­£å¸¸ç»“æœ', 'æˆ‘çš„å®åŠ›ä½ è¿˜æ˜¯çœ‹æ¸…æ¥šäº†å§']
                },
                shy: {
                    user_win: ['ä½ å¥½å‰å®³...', 'æˆ‘è¿˜éœ€è¦å¤šåŠªåŠ›...', 'æ­å–œä½ ...'],
                    draw: ['æˆ‘ä»¬éƒ½å¾ˆåŠªåŠ›å‘¢...', 'å¤§å®¶éƒ½åŠ æ²¹...', 'ä¸‹æ¬¡ç»§ç»­åŠªåŠ›...'],
                    user_loss: ['ä¸å¥½æ„æ€...', 'æˆ‘è¿™æ¬¡è¿æ°”æ¯”è¾ƒå¥½...', 'ä½ å·²ç»å¾ˆæ£’äº†...']
                },
                aggressive: {
                    user_win: ['å¯æ¶ï¼ä¸‹æ¬¡æˆ‘ä¸€å®šè¦èµ¢å›æ¥ï¼', 'è¿™æ¬¡ç®—ä½ è¿æ°”å¥½ï¼', 'æˆ‘ç»ä¸ä¼šè®¤è¾“çš„ï¼'],
                    draw: ['åˆ‡ï¼Œè¿™æ¬¡å°±ç®—å¹³æ‰‹å§ï¼', 'ä¸‹æ¬¡æˆ‘è¦å½»åº•å‡»è´¥ä½ ï¼', 'è¿˜ç®—å‡‘åˆå§'],
                    user_loss: ['å“ˆï¼æˆ‘å°±çŸ¥é“ä½ ä¸è¡Œï¼', 'è¿™å°±æ˜¯å®åŠ›å·®è·ï¼', 'ä¸‹æ¬¡è¿˜æ•¢æ¥å—ï¼Ÿ']
                },
                supportive: {
                    user_win: ['å¤ªæ£’äº†ï¼ä½ è¿›æ­¥å¾ˆå¤§ï¼', 'çœŸä¸ºä½ é«˜å…´ï¼', 'ä½ çš„åŠªåŠ›å¾—åˆ°äº†å›æŠ¥ï¼'],
                    draw: ['æˆ‘ä»¬éƒ½å¾ˆæ£’ï¼', 'ç»§ç»­ä¿æŒè¿™ä¸ªçŠ¶æ€ï¼', 'ä¸€èµ·åŠ æ²¹ï¼'],
                    user_loss: ['åˆ«ç°å¿ƒï¼Œä½ å·²ç»åšå¾—å¾ˆå¥½äº†ï¼', 'ä¸‹æ¬¡ä¸€å®šå¯ä»¥çš„ï¼', 'å¤±è´¥æ˜¯æˆåŠŸä¹‹æ¯ï¼']
                },
                silent: {
                    user_win: ['...ï¼ˆç‚¹å¤´è¡¨ç¤ºè®¤å¯ï¼‰', 'ï¼ˆæ²‰é»˜åœ°é¼“æŒï¼‰', '...'],
                    draw: ['...ï¼ˆæ¡æ‰‹ï¼‰', 'ï¼ˆç‚¹å¤´ï¼‰', '...'],
                    user_loss: ['...ï¼ˆæ·¡ç„¶åœ°ç¦»å¼€ï¼‰', 'ï¼ˆé»˜é»˜æ”¶æ‹¾ä¸œè¥¿ï¼‰', '...']
                }
            };
            
            return reactions[personality]?.[result] || ['å¥½çš„æ¯”èµ›ï¼', 'ä¸‹æ¬¡å†æ¥ï¼', 'ç»§ç»­åŠªåŠ›ï¼'];
        }
        
        function ignorePK() {
            if (gameData.pkChallenge) {
                const opponent = gameData.pkChallenge.opponent;
                // å¿½ç•¥PKä¼šè½»å¾®æ¶åŒ–å…³ç³»
                opponent.relationshipWithUser -= 0.02;
                
                gameData.pkChallenge = null;
                showNotification('å·²å¿½ç•¥PKæŒ‘æˆ˜');
            }
            document.getElementById('pkSection').style.display = 'none';
        }
        
        function checkDailyReset() {
            const today = new Date().toDateString();
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯æ–°çš„ä¸€å¤©
            if (gameData.lastLoginDate !== today) {
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                const yesterdayString = yesterday.toDateString();
                
                // å¦‚æœæ˜¨å¤©æœ‰ä»»åŠ¡ä½†æœªå®Œæˆï¼Œè¿›è¡Œæƒ©ç½š
                if (gameData.lastTaskDate === yesterdayString) {
                    const completionRate = gameData.completedTasks.length / Math.max(gameData.tasks.length, 1);
                    
                    if (completionRate < 0.6) { // å®Œæˆåº¦ä½äº60%
                        applyDailyPenalty(completionRate);
                    } else if (completionRate >= 0.8) { // å®Œæˆåº¦80%ä»¥ä¸Š
                        applyDailyBonus(completionRate);
                    }
                    
                    // æ›´æ–°è¿ç»­å®Œæˆå¤©æ•°
                    if (completionRate >= 0.7) {
                        gameData.streakDays++;
                    } else {
                        gameData.streakDays = 0;
                    }
                } else if (gameData.lastTaskDate && gameData.lastTaskDate < yesterdayString) {
                    // æ˜¨å¤©æ²¡æœ‰ä»»åŠ¡ï¼ˆæ–­ç­¾ï¼‰
                    gameData.streakDays = 0;
                    showNotification('âš ï¸ æ˜¨å¤©æ²¡æœ‰å­¦ä¹ ä»»åŠ¡ï¼Œè¿ç»­å®Œæˆå¤©æ•°é‡ç½®ï¼', 'error');
                }
                
                // é‡ç½®å½“å¤©æ•°æ®
                gameData.todayPower = 0;
                gameData.completedTasks = [];
                gameData.tasks = [];
                gameData.lastLoginDate = today;
                
                // è™šæ‹Ÿç©å®¶çŠ¶æ€æ›´æ–°
                updateVirtualPlayers();
                
                // éšæœºæ”¹å˜å·å·å¿ƒæƒ…
                const moods = ['happy', 'hungry', 'sleepy', 'excited'];
                gameData.catMood = moods[Math.floor(Math.random() * moods.length)];
                
                saveData();
                showDailyReport();
            }
        }
        
        function applyDailyPenalty(completionRate) {
            const penaltyLevel = completionRate < 0.3 ? 'severe' : completionRate < 0.6 ? 'moderate' : 'light';
            
            let penaltyText = '';
            
            switch (penaltyLevel) {
                case 'severe':
                    // ä¸¥é‡æƒ©ç½šï¼šæ‰2æ˜Ÿ + æ’åä¸‹é™
                    if (gameData.rank.stars >= 2) {
                        gameData.rank.stars -= 2;
                    } else {
                        gameData.rank.stars = 5 - (2 - gameData.rank.stars);
                        if (gameData.rank.tier < 5) {
                            gameData.rank.tier++;
                        } else {
                            const rankOrder = ['king', 'master', 'diamond', 'platinum', 'gold', 'silver', 'bronze'];
                            const currentIndex = rankOrder.indexOf(gameData.rank.level);
                            if (currentIndex < rankOrder.length - 1) {
                                gameData.rank.level = rankOrder[currentIndex + 1];
                                gameData.rank.tier = 1;
                            }
                        }
                    }
                    gameData.ranking = Math.min(10000, gameData.ranking + Math.floor(Math.random() * 200) + 100);
                    penaltyText = 'ğŸ˜± ä¸¥é‡æƒ©ç½šï¼šæ‰è½2æ˜Ÿï¼Œæ’åå¤§å¹…ä¸‹é™ï¼';
                    gameData.catMood = 'sad';
                    break;
                    
                case 'moderate':
                    // ä¸­ç­‰æƒ©ç½šï¼šæ‰1æ˜Ÿ
                    if (gameData.rank.stars > 1) {
                        gameData.rank.stars--;
                    } else {
                        gameData.rank.stars = 5;
                        if (gameData.rank.tier < 5) {
                            gameData.rank.tier++;
                        }
                    }
                    gameData.ranking = Math.min(10000, gameData.ranking + Math.floor(Math.random() * 100) + 50);
                    penaltyText = 'ğŸ˜” ä¸­ç­‰æƒ©ç½šï¼šæ‰è½1æ˜Ÿï¼Œæ’åä¸‹é™ï¼';
                    gameData.catMood = 'disappointed';
                    break;
                    
                case 'light':
                    // è½»å¾®æƒ©ç½šï¼šæ’åå°å¹…ä¸‹é™
                    gameData.ranking = Math.min(10000, gameData.ranking + Math.floor(Math.random() * 50) + 20);
                    penaltyText = 'ğŸ˜ è½»å¾®æƒ©ç½šï¼šæ’åå°å¹…ä¸‹é™';
                    break;
            }
            
            showNotification(penaltyText, 'error');
        }
        
        function applyDailyBonus(completionRate) {
            let bonusText = '';
            
            if (completionRate >= 0.95) {
                // å®Œç¾å®Œæˆï¼šé¢å¤–å¥–åŠ±
                gameData.rank.stars = Math.min(5, gameData.rank.stars + 1);
                gameData.ranking = Math.max(1, gameData.ranking - Math.floor(Math.random() * 50) - 20);
                
                // å®Œç¾å®Œæˆå¥–åŠ±
                const perfectRewards = [
                    { type: 'costume', name: 'å·å·ã€å®Œç¾ä¸»ä¹‰è€…å¾½ç« ã€‘è£…æ‰®', costume: 'å®Œç¾ä¸»ä¹‰è€…çš„é‡‘è‰²å¾½ç« ' },
                    { type: 'virtual', name: 'å®Œç¾å®Œæˆå¥–ç« Ã—1' },
                    { type: 'virtual', name: 'æŠ½å¡åˆ¸Ã—3' }
                ];
                const reward = perfectRewards[Math.floor(Math.random() * perfectRewards.length)];
                gameData.inventory.push(reward);
                
                bonusText = `ğŸŒŸ å®Œç¾å®Œæˆï¼è·å¾—1æ˜Ÿ+æ’åæå‡+${reward.name}ï¼`;
                gameData.catMood = 'excited';
                
            } else if (completionRate >= 0.8) {
                // ä¼˜ç§€å®Œæˆï¼šå°å¹…å¥–åŠ±
                gameData.ranking = Math.max(1, gameData.ranking - Math.floor(Math.random() * 30) - 10);
                gameData.inventory.push({ type: 'virtual', name: 'æŠ½å¡åˆ¸Ã—1' });
                
                bonusText = 'âœ¨ ä¼˜ç§€å®Œæˆï¼æ’åæå‡+æŠ½å¡åˆ¸Ã—1ï¼';
                gameData.catMood = 'happy';
            }
            
            if (bonusText) {
                showNotification(bonusText);
            }
        }
        
        function showDailyReport() {
            if (gameData.streakDays > 0 || gameData.stats.totalTasksCompleted > 0) {
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'block';
                
                const streakText = gameData.streakDays > 0 ? 
                    `ğŸ”¥ è¿ç»­å®Œæˆï¼š${gameData.streakDays}å¤©` : 
                    'ğŸ’” è¿ç»­å®Œæˆå·²ä¸­æ–­';
                    
                const rankText = `${['é’é“œ', 'ç™½é“¶', 'é»„é‡‘', 'é“‚é‡‘', 'é’»çŸ³', 'æ˜Ÿè€€', 'ç‹è€…'][['bronze', 'silver', 'gold', 'platinum', 'diamond', 'master', 'king'].indexOf(gameData.rank.level)]}${'â… â…¡â…¢â…£â…¤'[gameData.rank.tier-1]} ${'â˜…'.repeat(gameData.rank.stars)}${'â˜†'.repeat(5-gameData.rank.stars)}`;
                
                modal.innerHTML = `
                    <div class="modal-content">
                        <div class="modal-header" style="background: linear-gradient(135deg, #f093fb, #f5576c); color: white;">
                            ğŸ“Š æ¯æ—¥æ€»ç»“
                        </div>
                        <div class="modal-body">
                            <div style="text-align: center; margin: 20px 0;">
                                <div style="font-size: 18px; margin-bottom: 10px;">ğŸŒ… æ–°çš„ä¸€å¤©å¼€å§‹äº†ï¼</div>
                                <div style="margin: 10px 0;">${streakText}</div>
                                <div style="margin: 10px 0;">ğŸ† å½“å‰æ®µä½ï¼š${rankText}</div>
                                <div style="margin: 10px 0;">ğŸ“ˆ å½“å‰æ’åï¼šç¬¬${gameData.ranking}å</div>
                                <div style="margin: 10px 0;">ğŸ“š ç´¯è®¡å®Œæˆï¼š${gameData.stats.totalTasksCompleted}ä¸ªä»»åŠ¡</div>
                                ${gameData.streakDays >= 7 ? '<div style="color: #10b981; margin: 10px 0;">ğŸ‰ è¿ç»­å®Œæˆä¸€å‘¨ï¼è·å¾—ç‰¹æ®Šå¥–åŠ±ï¼</div>' : ''}
                            </div>
                            <button class="btn btn-primary" onclick="this.closest('.modal').remove()">å¼€å§‹æ–°ä¸€å¤©çš„å­¦ä¹ ï¼</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // è¿ç»­å®Œæˆä¸€å‘¨çš„ç‰¹æ®Šå¥–åŠ±
                if (gameData.streakDays >= 7 && gameData.streakDays % 7 === 0) {
                    gameData.inventory.push({
                        type: 'costume',
                        name: 'å·å·ã€ä¸ƒæ—¥è¾¾æˆè€…ã€‘è£…æ‰®',
                        costume: 'è±¡å¾ä¸ƒæ—¥åšæŒçš„å½©è™¹å›´å·¾'
                    });
                    
                    // æœ‰5%æ¦‚ç‡è·å¾—ç°å®å¥–åŠ±
                    if (Math.random() < 0.05) {
                        const realReward = REWARD_LIBRARY.realRewards[Math.floor(Math.random() * REWARD_LIBRARY.realRewards.length)];
                        gameData.inventory.push({
                            type: 'real',
                            name: realReward
                        });
                        showNotification(`ğŸ è¿ç»­å®Œæˆä¸€å‘¨ç‰¹æ®Šå¥–åŠ±ï¼š${realReward}ï¼`);
                    }
                }
            }
        }
        
        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type}`;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }
        
        function claimReward(reward) {
            gameData.inventory.push({ name: reward });
            showNotification(`ğŸ ${reward} å·²æ”¾å…¥ä»“åº“ï¼`);
            saveData();
        }
        
        function showInventory() {
            let inventoryHTML = gameData.inventory.length === 0 
                ? 'ä»“åº“ç©ºç©ºå¦‚ä¹Ÿ...' 
                : gameData.inventory.map(item => `
                    <div style="padding: 8px; margin: 4px 0; background: #f8fafc; border-radius: 6px;">
                        ${item.name}
                    </div>
                `).join('');
            
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">ğŸ“¦ æˆ‘çš„ä»“åº“</div>
                    <div class="modal-body">
                        <div style="max-height: 300px; overflow-y: auto;">
                            ${inventoryHTML}
                        </div>
                        <button class="btn btn-secondary" onclick="this.closest('.modal').remove()">å…³é—­</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        // é”®ç›˜å¿«æ·é”®
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.target.id === 'taskInput') {
                completeTask();
            }
            if (e.key === 'Enter' && e.target.id === 'aiInput') {
                sendToAI();
            }
            if (e.key === 'Escape') {
                closeModal();
            }
        });
        
        // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('modal')) {
                closeModal();
            }
        });
        
        // æ³¨å†ŒService Worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('data:text/javascript,console.log("SW registered")')
                    .then(() => console.log('SW registered'))
                    .catch(() => console.log('SW registration failed'));
            });
        }
        
        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            initApp();
            setupFileUpload();
        });
    </script>
</body>
</html>